å¸¸ç”¨ Deep Link ç¯„æœ¬
1) ç¾¤çµ„èŠå¤© / ç§èŠï¼ˆChatï¼‰
æœ€ç©©çš„å…©ç¨®ä½œæ³•ï¼š
ä¾ã€Œæˆå“¡ emailã€é–‹èŠï¼ˆä¸éœ€ chatIdï¼‰
https://teams.microsoft.com/l/chat/0/0?users=user1@yourtenant.com,user2@yourtenant.com&topicName=ç¾¤çµ„é¡¯ç¤ºåç¨±
users ç”¨é€—è™Ÿåˆ†éš”å¤šä½æˆå“¡ï¼ˆéœ€è¦èƒ½äº’ç›¸èŠå¤©çš„åŒç§Ÿæˆ¶/å—ä¿¡ä»»ç¶²åŸŸï¼‰
å¯é¸ topicName= è‡ªè¨‚ç¾¤çµ„åç¨±ï¼ˆéœ€ URL encodeï¼‰
ç”¨æ—¢æœ‰ chatIdï¼ˆæœ€ä¿éšªï¼‰
å…ˆåœ¨ Teams Web æ‰“é–‹è©²ç¾¤çµ„èŠå¤©ï¼Œç¶²å€å¸¸å« 19:xxxxxxxx@thread.tacv2
å¯ç”¨èˆŠæ ¼å¼ç›´æ¥é–‹åˆ°è©²èŠå¤©è¦–åœ–ï¼ˆç›¸å®¹æ€§é«˜ï¼‰ï¼š
https://teams.microsoft.com/_#/conversations/19:XXXXXXXX@thread.tacv2?ctx=chat

å–å¾— chatId çš„å°æŠ€å·§ï¼šæ‰“é–‹èŠå¤© â†’ é–‹ DevTools console è¼¸å…¥ location.hrefï¼Œ
æˆ–ç›´æ¥è¤‡è£½ç¶²å€åˆ—ï¼›å…¶ä¸­é‚£æ®µ 19:...@thread.tacv2 å°±æ˜¯ chatIdã€‚


2) åœ˜éšŠé »é“ï¼ˆChannelï¼‰

ç”¨ Teams å…§å»ºã€Œå–å¾—é€£çµåˆ°é »é“ã€å¾—åˆ°çš„é€£çµï¼ˆå³éµé »é“ â†’ å–å¾—é€£çµåˆ°é »é“ï¼‰ï¼š
https://teams.microsoft.com/l/channel/<channelId>/<channelName-URLENCODED>?groupId=<teamId>&tenantId=<tenantId>
é€™æ¢å®˜æ–¹ã€Œé »é“é€£çµã€æœ€ç©©ï¼Œç›´æ¥ driver.get() å°±æœƒæ‰“é–‹åˆ°è©²é »é“ã€‚
channelName éœ€ URL encodeï¼ˆTeams è‡ªå·±çµ¦çš„é€£çµå·²è™•ç†å¥½ï¼‰ã€‚


Seleniumï¼šç”¨é€£çµç›´é” + ç™¼è¨Šæ¯

æŠŠä½ åŸæœ¬çš„é™„è‘—æ¨¡å¼ä¿ç•™ï¼Œåªæ˜¯æŠŠã€Œæœå°‹èŠå¤©ã€æ›æˆã€Œé–‹ Deep Linkã€ã€‚
ä»¥ä¸‹ç¤ºç¯„å…©å€‹å…¥å£å‡½å¼ï¼šopen_chat_by_link() èˆ‡ open_channel_by_link()ã€‚

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
from urllib.parse import quote
import time

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    drv = webdriver.Chrome(service=service, options=opts)
    drv.implicitly_wait(0)
    return drv

def wait_compose_box(driver, timeout=30):
    """ç­‰å¾…è¨Šæ¯è¼¸å…¥æ¡†å¯ç”¨ï¼ˆChat/Channel çš†é€šç”¨ï¼‰ã€‚"""
    # æœ‰æ™‚å€™è¼¸å…¥æ¡†åœ¨ iframeï¼Œå…ˆå˜—è©¦åˆ‡
    driver.switch_to.default_content()
    frames = driver.find_elements(By.CSS_SELECTOR, "iframe")
    for f in frames:
        driver.switch_to.default_content()
        try:
            driver.switch_to.frame(f)
            if driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']"):
                break
        except Exception:
            pass
    # å›ä¸»æ–‡æª”å†æ‰¾ä¸€æ¬¡
    driver.switch_to.default_content()
    box = WebDriverWait(driver, timeout).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']"))
    )
    return box

def send_text(driver, text):
    compose = wait_compose_box(driver, timeout=40)
    compose.click()
    for line in text.split("\n"):
        compose.send_keys(line)
        compose.send_keys(Keys.SHIFT, Keys.ENTER)
    compose.send_keys(Keys.BACK_SPACE)  # ç§»é™¤æœ€å¾Œä¸€å€‹å¤šé¤˜æ›è¡Œ
    compose.send_keys(Keys.ENTER)

def open_chat_by_link(driver, *, users=None, topic_name=None, chat_id=None):
    """
    users: ä»¥ email åˆ—è¡¨é–‹å•Ÿ/å»ºç«‹ç¾¤çµ„èŠå¤©ï¼ˆç„¡éœ€ chatIdï¼‰
    chat_id: å·²çŸ¥ 19:...@thread.tacv2
    """
    if chat_id:
        url = f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat"
    elif users:
        users_param = ",".join(users)
        url = f"https://teams.microsoft.com/l/chat/0/0?users={users_param}"
        if topic_name:
            url += f"&topicName={quote(topic_name)}"
    else:
        raise ValueError("éœ€æä¾› users æˆ– chat_id å…¶ä¸€")
    driver.get(url)
    # ç­‰ä¸»ç•«é¢èˆ‡è¼¸å…¥æ¡†
    send_text(driver, "ï¼ˆæ¸¬è©¦ï¼‰é€™æ˜¯å¾ Deep Link ç›´é”èŠå¤©å¾Œç™¼é€çš„è¨Šæ¯ âœ…")

def open_channel_by_link(driver, *, channel_id, team_id, tenant_id, channel_name):
    """
    ç›´æ¥æ‰“é–‹é »é“ã€‚é€šå¸¸ä½ å¯ä»¥å¾ã€Œå–å¾—é€£çµåˆ°é »é“ã€è¤‡è£½å®Œæ•´ URLï¼Œ
    ä¹Ÿå¯ç”¨æ­¤å‡½å¼è‡ªè¡Œçµ„å‡ºä¾†ï¼ˆè¨˜å¾— channel_name è¦ URL encodeï¼‰ã€‚
    """
    url = (
        "https://teams.microsoft.com/l/channel/"
        f"{channel_id}/{quote(channel_name)}"
        f"?groupId={team_id}&tenantId={tenant_id}"
    )
    driver.get(url)
    # é »é“çš„è¨Šæ¯è¼¸å…¥æ¡†åŒæ¨£æ˜¯ contenteditable textbox
    send_text(driver, "ï¼ˆæ¸¬è©¦ï¼‰é€™æ˜¯å¾ Deep Link ç›´é”é »é“å¾Œç™¼é€çš„è¨Šæ¯ ğŸ“£")

if __name__ == "__main__":
    driver = build_driver()

    # âœ… ç¯„ä¾‹ Aï¼šç”¨ email é–‹å•Ÿç¾¤çµ„èŠå¤©
    # open_chat_by_link(
    #     driver,
    #     users=["alice@yourtenant.com", "bob@yourtenant.com"],
    #     topic_name="è‡ªå‹•åŒ–æ¸¬è©¦ç¾¤çµ„"
    # )

    # âœ… ç¯„ä¾‹ Bï¼šç”¨å·²çŸ¥ chatId ç›´é–‹
    # open_chat_by_link(driver, chat_id="19:xxxxxxxxxxxxxxxx@thread.tacv2")

    # âœ… ç¯„ä¾‹ Cï¼šç”¨é »é“ Link ç›´é–‹
    # open_channel_by_link(
    #     driver,
    #     channel_id="19:yyyyyyyyyyyyyyyy@thread.tacv2",
    #     team_id="00000000-1111-2222-3333-444444444444",
    #     tenant_id="aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
    #     channel_name="ä¸€èˆ¬"
    # )



å¯¦å‹™å–å¾—åƒæ•¸çš„æ–¹æ³•

é »é“ï¼ˆChannelï¼‰
åœ¨ Teams ä»‹é¢ â†’ å³éµé »é“ â†’ã€Œå–å¾—é€£çµåˆ°é »é“ã€ï¼Œç›´æ¥è²¼å‡ºä¾†å°±æ˜¯å¯ç”¨çš„ l/channel/... é€£çµï¼ˆè£¡é¢å« channelIdã€groupIdã€tenantId èˆ‡å·²ç·¨ç¢¼çš„ channelNameï¼‰ã€‚

ç¾¤çµ„èŠå¤©ï¼ˆChatï¼‰

ç„¡ chatId çš„æƒ…æ³ï¼šç›´æ¥ç”¨ users=email1,email2,...ã€‚

å·²å­˜åœ¨ç¾¤çµ„èŠå¤©ä¸”æƒ³å›ºå®šåŒä¸€å€‹åŸ·è¡Œç·’ï¼šå…ˆé–‹åˆ°è©²èŠå¤© â†’ å¾ç¶²å€åˆ—æˆ– location.href æŠ“åˆ° 19:...@thread.tacv2ï¼Œå‚³çµ¦ chat_idã€‚
å¸¸è¦‹å‘ä½èˆ‡é¿å…

URL ç·¨ç¢¼ï¼šchannelNameã€topicName éƒ½è¦ URL encodeï¼ˆä¸Šé¢ç”¨ urllib.parse.quote äº†ï¼‰ã€‚

ç§Ÿæˆ¶é™åˆ¶ï¼šè·¨ç§Ÿæˆ¶/å¤–éƒ¨ä¾†è³“å¯èƒ½æ‰“ä¸é–‹ users= èŠå¤©ï¼›é€™æ™‚å°±å…ˆæ‹¿åˆ°è©²èŠå¤©çš„ chatId æœ€ç©©ã€‚

è¼¸å…¥æ¡†åœ¨ iframeï¼šç¨‹å¼å·²åšåˆ‡æ›å˜—è©¦ï¼›è‹¥ä½ ç’°å¢ƒé‚„æœ‰è‡ªè¨‚å®¹å™¨ï¼Œå¯èƒ½è¦é¡å¤–æŒ‡å®š driver.switch_to.frame(...)ã€‚

Enter å‹•ä½œï¼šè‹¥è²´å¸æŠŠã€ŒEnter=æ›è¡Œã€ï¼Œè«‹æ”¹ç‚ºæ‰¾ã€Œå‚³é€ã€æŒ‰éˆ•é»æ“Šï¼š

send_btn = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label*='å‚³é€'], button[aria-label='Send']"))
)
send_btn.click()


------------------------------------------------------------------

å¯ä»¥ã€Œå¼·åˆ¶ç”¨ Web ç‰ˆ Teams é–‹é€£çµï¼Œä¸è¦è·³å‡ºæ¡Œé¢ Teams Appã€ã€‚
Teams Deep Link é è¨­æœƒæª¢æŸ¥ç³»çµ±ï¼Œå¦‚æœé›»è…¦å®‰è£äº† Teams Appï¼Œé€šå¸¸æœƒå…ˆå˜—è©¦å«èµ· Appã€‚è¦é¿å…é€™ç¨®æƒ…æ³æœ‰å¹¾å€‹æŠ€å·§ï¼š

æ–¹æ³• 1ï¼šåœ¨ Selenium ç›´æ¥é–‹ teams.microsoft.com/...

å¦‚æœä½ ç”¨ Selenium çš„ driver.get(url)ï¼Œå®ƒæœ¬è³ªå°±æ˜¯æ‰“é–‹ä¸€å€‹ç¶²å€ï¼Œç€è¦½å™¨ä¸æœƒè‡ªå‹•è·³å» Appã€‚
æ‰€ä»¥åªè¦ä½ ç”¨çš„æ˜¯ https://teams.microsoft.com/l/... æˆ– https://teams.microsoft.com/_#/... é€™ç¨®é€£çµï¼ŒSelenium ä¸€å®šæ˜¯åœ¨ Chrome è£¡è·‘ï¼Œä¸æœƒæ‰“é–‹ Appã€‚
ï¼ˆå”¯ç¨ä½¿ç”¨è€…æ‰‹å‹•é» Teams èŠå¤©è£¡çš„ã€Œé–‹å•Ÿ Appã€æŒ‰éˆ•ï¼Œæ‰æœƒè§¸ç™¼ã€‚ï¼‰

æ–¹æ³• 2ï¼šåœ¨ç¶²å€å¾Œé¢åŠ  &web=1

å¾®è»Ÿå®˜æ–¹ Deep Link æ”¯æ´ ?web=1 æˆ– &web=1 åƒæ•¸ï¼Œæœƒå¼·åˆ¶ä½¿ç”¨ Web Teamsï¼Œå³ä½¿æœ¬æ©Ÿæœ‰æ¡Œé¢ç‰ˆ Teamsã€‚
ç¯„ä¾‹ï¼š

ç¾¤çµ„èŠå¤©ï¼ˆchatIdï¼‰ï¼š
https://teams.microsoft.com/_#/conversations/19:XXXXXXXX@thread.tacv2?ctx=chat&web=1
é »é“ï¼š
https://teams.microsoft.com/l/channel/19:YYYYYYYY@thread.tacv2/%E4%B8%80%E8%88%AC?groupId=...&tenantId=...&web=1

åªè¦åŠ ä¸Š &web=1ï¼ŒTeams æœƒå›ºå®šåœ¨ç€è¦½å™¨æ‰“é–‹ï¼Œä¸æœƒå†æç¤ºè·³è½‰ Appã€‚


æ–¹æ³• 3ï¼šç€è¦½å™¨å±¤ç´šç¦æ­¢ã€Œteams://ã€å”è­°
å¦‚æœç’°å¢ƒå…§ IT é è¨­é‚„æ˜¯æœƒè·³è½‰ï¼Œå¯ä»¥é¡å¤–åœ¨ Chrome å•Ÿå‹•åƒæ•¸åŠ å…¥ï¼š
--disable-features=msEdgeRedirectForTeams

æˆ–é€é GPO/ç³»çµ±æŠŠ teams:// å”è­°ç§»é™¤ã€‚ä¸éé€šå¸¸æ–¹æ³• 2 å°±å¤ ã€‚

------------------------------------------------------------------------------
Selenium ç¯„ä¾‹ï¼ˆå¼·åˆ¶ Webï¼‰

def open_chat_by_link(driver, chat_id):
    url = f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1"
    driver.get(url)
    send_text(driver, "ï¼ˆæ¸¬è©¦ï¼‰å¼·åˆ¶ Web Teams ç™¼é€ âœ…")

def open_channel_by_link(driver, channel_id, team_id, tenant_id, channel_name):
    from urllib.parse import quote
    url = (
        "https://teams.microsoft.com/l/channel/"
        f"{channel_id}/{quote(channel_name)}"
        f"?groupId={team_id}&tenantId={tenant_id}&web=1"
    )
    driver.get(url)
    send_text(driver, "ï¼ˆæ¸¬è©¦ï¼‰é »é“è¨Šæ¯ via Web Teams ğŸ“£")

çµè«–ï¼š
ä½ åªè¦åœ¨ Teams é€£çµå¾ŒåŠ  &web=1ï¼Œå†ç”¨ driver.get(url)ï¼ŒSelenium å°±æœƒå›ºå®šç”¨ Chrome é–‹ Web Teamsï¼Œä¸æœƒè·‘å» Teams Appã€‚


--------------------------------------------------------------------------------

Web Teamsï¼ˆä¹Ÿå°±æ˜¯ä½ ç¾åœ¨é€é Selenium æ“ä½œçš„ teams.microsoft.comï¼‰è£¡ï¼Œã€Œè²¼ä¸Šè¡¨æ ¼æˆ–åœ–ç‰‡ã€è·Ÿå–®ç´”æ–‡å­—ä¸ä¸€æ¨£ï¼Œè¦åˆ†æƒ…æ³ï¼š
1. è¡¨æ ¼
Teams æœ¬èº«æ²’æœ‰åŸç”Ÿã€Œè¡¨æ ¼ç·¨è¼¯å™¨ã€ï¼Œæ‰€ä»¥ä½ ä¸èƒ½åƒ Word ä¸€æ¨£ç›´æ¥å»ºç«‹è¡¨æ ¼ã€‚
å¸¸è¦‹åšæ³•ï¼š

å¾ Excel / Word è¤‡è£½è¡¨æ ¼ â†’ åœ¨ Teams è¨Šæ¯æ¡†è²¼ä¸Šï¼Œæœƒè®Šæˆã€Œæ–‡å­—æ’ç‰ˆã€ï¼ˆç©ºæ ¼ / tabï¼‰æˆ–ã€ŒRich Text æ ¼å¼ã€ï¼ˆå–æ±ºæ–¼ä¾†æºï¼‰ã€‚

ç”¨ Markdown-like æ ¼å¼ï¼ˆä¾‹å¦‚ | æ¬„1 | æ¬„2 |ï¼‰ â†’ ç›®å‰ Web Teams æœƒç•¶æˆç´”æ–‡å­—ï¼Œä¸æœƒæ¸²æŸ“æˆè¡¨æ ¼ã€‚

æ”¹ç”¨åœ–ç‰‡ï¼šå…ˆæŠŠè¡¨æ ¼è½‰æˆåœ–ç‰‡ï¼ˆä¾‹å¦‚ç”¨ Python ç”Ÿæˆ PNGï¼Œæˆ–æˆªåœ–ï¼‰ï¼Œå†ä¸Šå‚³åœ–ç‰‡åˆ° Teamsï¼ˆæœ€ç©©ï¼‰ã€‚


2. åœ–ç‰‡

Web Teams æ”¯æ´åœ–ç‰‡ä¸Šå‚³ï¼Œæ–¹å¼æœ‰å…©ç¨®ï¼š
æ‹–æ›³æª”æ¡ˆ / è²¼ä¸Šåœ–ç‰‡
ç›´æ¥æŠŠåœ–ç‰‡æª”ï¼ˆæˆ–å‰ªè²¼ç°¿åœ–ç‰‡ï¼‰ä¸Ÿé€²è¼¸å…¥æ¡†ï¼Œæœƒè‡ªå‹•ä¸Šå‚³æˆé™„ä»¶ã€‚
ä½† Selenium è¦æ¨¡æ“¬é€™å€‹è¡Œç‚ºï¼Œå°±å¿…é ˆæ‰¾åˆ°æª”æ¡ˆä¸Šå‚³ <input type="file">ã€‚
é»ã€Œè¿´ç´‹é‡ã€ä¸Šå‚³æŒ‰éˆ•
åœ¨è¼¸å…¥æ¡†å·¦ä¸‹è§’é€šå¸¸æœ‰å€‹ã€ŒğŸ“ï¼ˆé™„åŠ æª”æ¡ˆï¼‰ã€æŒ‰éˆ•ï¼Œé»å®ƒæœƒæ‰“é–‹ <input type="file">ã€‚
Selenium å¯ä»¥é€™æ¨£åšï¼š
upload_input = driver.find_element(By.CSS_SELECTOR, "input[type='file']")
upload_input.send_keys(r"C:\path\to\your\image.png")


3. Selenium è‡ªå‹•åŒ–é›£é»
è¡¨æ ¼ï¼šé™¤éä½ æ¥å—ã€Œç´”æ–‡å­—è¡¨æ ¼ã€ï¼Œå¦å‰‡è¦å…ˆæŠŠè¡¨æ ¼å­˜æˆåœ–ç‰‡å†ä¸Šå‚³ã€‚
åœ–ç‰‡ï¼šå¿…é ˆé€é <input type=file> ä¸Šå‚³ï¼Œä¸æ”¯æ´ send_keys(Keys.CONTROL, 'v') é€™ç¨®ç›´æ¥è²¼åœ–ã€‚
Rich Textï¼ˆç²—é«”ã€æ–œé«”ã€é€£çµï¼‰ï¼šWeb Teams è¨Šæ¯æ¡†æ˜¯ contenteditableï¼Œ
å…¶å¯¦å¯ä»¥æ’å…¥ HTMLï¼Œä½† Selenium åŸç”Ÿåªèƒ½ç™¼å­—å…ƒï¼›è‹¥è¦æ’ HTMLï¼Œè¦ç”¨ JavaScript æ³¨å…¥ã€‚


å»ºè­°åšæ³•ï¼ˆçµ¦ä½  Python Selenium æ–¹å‘ï¼‰ï¼š
å¦‚æœè¦è¡¨æ ¼ â†’ å»º PNG â†’ ä¸Šå‚³åœ–ç‰‡ï¼ˆæœ€ç©©ï¼‰ã€‚
å¦‚æœè¦ç´”æ–‡å­—è¡¨æ ¼ â†’ ç”¨ \t æˆ– | æ‹¼å­—ä¸²é€å‡ºã€‚
åœ–ç‰‡ä¸Šå‚³ â†’ æ‰¾ input[type=file] â†’ send_keys(æª”æ¡ˆè·¯å¾‘)ã€‚




ã€ŒæŠŠ pandas DataFrame è½‰æˆ PNG åœ–ç‰‡ â†’ é€é Selenium ä¸Šå‚³åˆ° Web Teamsï¼ˆå¼·åˆ¶ webï¼‰â†’ é€å‡ºè¨Šæ¯ã€çš„å®Œæ•´ç¯„ä¾‹ã€‚
ä½ åªè¦æ”¹å¹¾å€‹åƒæ•¸ï¼ˆchat_id æˆ– channel link åƒæ•¸ã€ä»¥åŠä½ çš„æª”æ¡ˆè·¯å¾‘/è¨Šæ¯ï¼‰ï¼Œå°±èƒ½ç›´æ¥ç”¨ã€‚

åŠŸèƒ½èªªæ˜

df_to_png()ï¼šæŠŠ pandas.DataFrame æ¸²æŸ“æˆæ¸…æ™°çš„ PNGï¼ˆç”¨ matplotlibï¼Œä¸éœ€é¡å¤–å¥—ä»¶ï¼‰ã€‚

open_chat_by_link() / open_channel_by_link()ï¼šç”¨ Teams Deep Link ç›´æ¥é–‹åˆ°èŠå¤©æˆ–é »é“ï¼ˆå¸¶ &web=1 å¼·åˆ¶åœ¨ç€è¦½å™¨ï¼‰ã€‚

upload_image_and_send()ï¼šæ‰¾åˆ°éš±è—çš„ <input type="file"> ä¸Šå‚³åœ–ç‰‡ï¼Œç­‰å¾…é è¦½è¼‰å…¥å¾Œé€å‡ºè¨Šæ¯ã€‚

å·²ç¶“è€ƒæ…®å¤šåœ‹èªç³»èˆ‡å¤šç¨® DOM ç‰ˆæœ¬ï¼Œæä¾›å¤šçµ„ selector å€™é¸ï¼›ä¹Ÿè™•ç†äº†å¯èƒ½çš„ iframeã€‚

ä½ å·²ç¶“æ˜¯ç”¨ --remote-debugging-port=9992 çš„æ–¹å¼é™„è‘— Chromeï¼Œä¸‹ä¾‹æ²¿ç”¨åŒæ¨£åšæ³•ã€‚


import os
import io
import time
from urllib.parse import quote

import pandas as pd
import matplotlib.pyplot as plt

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# ====== ä½ çš„ç’°å¢ƒè¨­å®š ======
DEBUGGER_ADDRESS = "127.0.0.1:9992"   # ä½ ç¾æœ‰ Chrome çš„ remote debugging port
CHROMEDRIVER_PATH = "chromedriver.exe"  # è¦–ä½ çš„ç’°å¢ƒä¿®æ­£

# ç›®æ¨™ï¼šæ“‡ä¸€ä½¿ç”¨ï¼ˆå…©ç¨®éƒ½ç¤ºç¯„ï¼›å¯¦éš›ç”¨æ™‚ç•™ä¸€å€‹ï¼‰
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"  # å·²å­˜åœ¨çš„ç¾¤çµ„/ç§èŠ IDï¼ˆå»ºè­°ï¼‰
# æˆ–è€…ç”¨ Channel Link çš„ 3 å€‹åƒæ•¸ï¼ˆå¾ã€Œå–å¾—é€£çµåˆ°é »é“ã€å¯æ‹¿åˆ°ï¼‰
CHANNEL_ID = "19:yyyyyyyyyyyyyyyy@thread.tacv2"
TEAM_ID = "00000000-1111-2222-3333-444444444444"
TENANT_ID = "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
CHANNEL_NAME = "ä¸€èˆ¬"  # æœƒåš URL encode

# ====== ç¯„ä¾‹ DataFrameï¼ˆä½ å¯ä»¥æ›æˆä½ çš„åˆ†æçµæœï¼‰======
def sample_dataframe():
    return pd.DataFrame({
        "ç”¢å“": ["A", "B", "C", "D"],
        "æœ¬æœˆéŠ·é‡": [120, 95, 143, 88],
        "é€€è²¨ç‡": [0.8, 1.2, 0.5, 1.0],
        "å‚™è¨»": ["ç©©å®š", "ç•¥é™", "æˆé•·", "è§€å¯Ÿ"]
    })

# ====== æŠŠ DataFrame è½‰æˆ PNG åœ–ç‰‡ ======
def df_to_png(df: pd.DataFrame, save_path: str, title: str = None, dpi: int = 200):
    """
    ç”¨ matplotlib æŠŠ DataFrame æ¸²æŸ“æˆè¡¨æ ¼åœ–ç‰‡ï¼ˆç„¡éœ€ dataframe-image å¥—ä»¶ï¼‰ã€‚
    """
    # å‹•æ…‹è¨ˆç®—åœ–å°ºå¯¸ï¼ˆé¿å…å­—å¤ªæ“ ï¼‰ï¼šæ¯åˆ—å›ºå®šé«˜åº¦ã€å¯¬åº¦ä¾æ¬„ä½æ•¸ä¼°
    n_rows, n_cols = df.shape
    cell_h = 0.6
    cell_w = 2.2
    title_h = 0.6 if title else 0.2
    fig_w = max(6, n_cols * cell_w)
    fig_h = max(2.5, n_rows * cell_h + title_h)

    fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
    ax.axis("off")

    # å»ºè¡¨æ ¼
    table = ax.table(cellText=df.values,
                     colLabels=df.columns,
                     loc='center',
                     cellLoc='center',
                     colLoc='center')

    # ç¾åŒ–ï¼šå­—é«”å¤§å°ã€æ¬„å¯¬ã€è¡¨é ­åŠ ç²—
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1, 1.25)

    # è¡¨é ­ç²—é«” + ç°åº•
    for (row, col), cell in table.get_celld().items():
        if row == 0:
            cell.set_text_props(weight='bold')
            cell.set_facecolor("#f0f0f0")
        # é‚Šæ¡†æ·¡ä¸€é»
        cell.set_edgecolor("#cccccc")

    # æ¨™é¡Œ
    if title:
        ax.set_title(title, pad=10, fontsize=14, fontweight='bold')

    # å„²å­˜
    os.makedirs(os.path.dirname(save_path), exist_ok=True) if os.path.dirname(save_path) else None
    plt.tight_layout()
    plt.savefig(save_path, bbox_inches='tight', dpi=dpi)
    plt.close(fig)
    return save_path

# ====== Selenium åŸºæœ¬å»ºç½® ======
def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    driver = webdriver.Chrome(service=service, options=opts)
    driver.implicitly_wait(0)
    return driver

def wait_any(driver, candidates, timeout=30, clickable=False):
    w = WebDriverWait(driver, timeout)
    last_err = None
    for by, sel in candidates:
        try:
            if clickable:
                return w.until(EC.element_to_be_clickable((by, sel)))
            else:
                return w.until(EC.presence_of_element_located((by, sel)))
        except Exception as e:
            last_err = e
    raise last_err

def ensure_web_teams_open(driver):
    if "teams.microsoft.com" not in driver.current_url:
        driver.get("https://teams.microsoft.com/_?web=1")

# ====== ç›´é”èŠå¤© / é »é“ï¼ˆå¼·åˆ¶ web=1ï¼‰======
def open_chat_by_link(driver, chat_id: str):
    url = f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1"
    driver.get(url)
    # ç­‰å¾…èŠå¤©è¼¸å…¥æ¡†å‡ºç¾
    wait_compose_box(driver, timeout=60)

def open_channel_by_link(driver, channel_id: str, team_id: str, tenant_id: str, channel_name: str):
    url = (
        "https://teams.microsoft.com/l/channel/"
        f"{channel_id}/{quote(channel_name)}"
        f"?groupId={team_id}&tenantId={tenant_id}&web=1"
    )
    driver.get(url)
    wait_compose_box(driver, timeout=60)

# ====== æ‰¾åˆ°è¼¸å…¥æ¡†ï¼ˆè€ƒæ…® iframeï¼‰======
def wait_compose_box(driver, timeout=40):
    driver.switch_to.default_content()
    # æœ‰æ™‚å€™è¼¸å…¥æ¡†åœ¨ iframeï¼Œé€ä¸€å˜—è©¦åˆ‡å…¥
    iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
    for f in iframes:
        driver.switch_to.default_content()
        try:
            driver.switch_to.frame(f)
            if driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']"):
                break
        except Exception:
            pass
    # å›ä¸»æ–‡æª”å†æ‰¾ä¸€æ¬¡
    driver.switch_to.default_content()
    box = WebDriverWait(driver, timeout).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']"))
    )
    return box

# ====== ä¸Šå‚³åœ–ç‰‡ä¸¦é€å‡º ======
def upload_image_and_send(driver, file_path: str, caption: str = None):
    """
    1) å°‹æ‰¾æª”æ¡ˆä¸Šå‚³ input[type=file]
    2) send_keys(file_path) è§¸ç™¼ä¸Šå‚³
    3) ç­‰é è¦½å®Œæˆå¾Œï¼Œè¼¸å…¥ï¼ˆå¯é¸ï¼‰èªªæ˜æ–‡å­—
    4) é€å‡º
    """
    driver.switch_to.default_content()

    # å…ˆè©¦è‘—é»ã€Œé™„åŠ /ä¸Šå‚³ã€æŒ‰éˆ•ï¼ˆæœ‰äº›ç‰ˆæœ¬éœ€è¦é»ä¸€ä¸‹æ‰æœƒæŠŠ input mount åˆ° DOMï¼‰
    try:
        attach_btn = wait_any(driver, [
            (By.CSS_SELECTOR, "button[aria-label*='é™„åŠ '], button[aria-label*='æª”æ¡ˆ'], button[aria-label='Attach']"),
            (By.CSS_SELECTOR, "button[title*='é™„åŠ '], button[title='Attach']"),
            (By.CSS_SELECTOR, "[data-tid*='attach'], [data-tid*='file-upload']"),
        ], timeout=5, clickable=True)
        attach_btn.click()
        time.sleep(0.5)
    except Exception:
        pass  # æ‰¾ä¸åˆ°ä¹Ÿæ²’é—œä¿‚ï¼Œä¸‹é¢æœƒç›´æ¥æ‰¾ input[type=file]

    # æ‰¾æ‰€æœ‰å¯ç”¨çš„ <input type=file>ï¼Œé€šå¸¸å…¶ä¸­ä¸€å€‹æ˜¯æˆ‘å€‘è¦çš„
    inputs = driver.find_elements(By.CSS_SELECTOR, "input[type='file']")
    if not inputs:
        # æœ‰äº›æƒ…æ³ input åœ¨ shadow host/iframe è£¡ï¼›å†æƒä¸€æ¬¡ iframe
        iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            driver.switch_to.default_content()
            try:
                driver.switch_to.frame(f)
                inputs = driver.find_elements(By.CSS_SELECTOR, "input[type='file']")
                if inputs:
                    break
            except Exception:
                pass
        driver.switch_to.default_content()

    if not inputs:
        raise RuntimeError("æ‰¾ä¸åˆ° input[type=file]ï¼Œè«‹åœ¨ä½ çš„ç’°å¢ƒç”¨ DevTools ç¢ºèªå¯¦éš› selector æˆ–å…ˆé»ä¸€æ¬¡ã€é™„åŠ æª”æ¡ˆã€ã€‚")

    # å˜—è©¦å°æ‰€æœ‰ file input åŸ·è¡Œ send_keysï¼Œæœ‰çš„è¢« hidden ä¹Ÿèƒ½æˆåŠŸ
    uploaded = False
    for inp in inputs:
        try:
            inp.send_keys(os.path.abspath(file_path))
            uploaded = True
            break
        except Exception:
            continue

    if not uploaded:
        raise RuntimeError("send_keys åˆ° input[type=file] å¤±æ•—ï¼Œå¯èƒ½è¢«é˜»æ“‹æˆ–åœ¨ shadow DOMï¼Œè«‹å›å ±å¯¦éš› DOM çµæ§‹èª¿æ•´ã€‚")

    # ç­‰å¾…ä¸Šå‚³é è¦½å‡ºç¾ï¼ˆå„ç‰ˆæœ¬ä¸åŒï¼Œæä¾›å¤šçµ„å€™é¸ï¼‰
    try:
        wait_any(driver, [
            (By.CSS_SELECTOR, "[data-tid*='filePreview'], [data-tid*='attachment'], [data-tid*='imagePreview']"),
            (By.CSS_SELECTOR, "img[alt*='é è¦½'], img[alt*='preview']"),
            (By.CSS_SELECTOR, "[role='listitem'] img, [data-tid*='attachment'] [role='img']"),
        ], timeout=30)
    except Exception:
        # æœ‰äº›ç¶²è·¯è¼ƒæ…¢ï¼Œå†ç·©ä¸€ä¸‹
        time.sleep(1)

    # è¼¸å…¥èªªæ˜æ–‡å­—ï¼ˆå¯é¸ï¼‰
    if caption:
        compose = wait_compose_box(driver, timeout=30)
        compose.click()
        for line in caption.split("\n"):
            compose.send_keys(line)
            compose.send_keys(Keys.SHIFT, Keys.ENTER)
        compose.send_keys(Keys.BACK_SPACE)

    # é€å‡ºï¼ˆè‹¥ä½ çš„ç§Ÿæˆ¶æŠŠ Enter=æ›è¡Œï¼Œè«‹æ”¹ç‚ºé»é€å‡ºæŒ‰éˆ•ï¼‰
    try:
        compose = wait_compose_box(driver, timeout=10)
        compose.send_keys(Keys.ENTER)
    except Exception:
        # æ”¹ç”¨é€å‡ºæŒ‰éˆ•
        send_btn = wait_any(driver, [
            (By.CSS_SELECTOR, "button[aria-label='Send']"),
            (By.CSS_SELECTOR, "button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"),
        ], timeout=10, clickable=True)
        send_btn.click()

    # ç°¡å–®ç¢ºèªè¨Šæ¯å·²å‡ºç¾
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"))
    )

# ====== ä¸»æµç¨‹ç¤ºç¯„ ======
def main():
    # 1) å…ˆæŠŠ DataFrame å­˜æˆ PNG
    df = sample_dataframe()
    out_png = "teams_out/table_report.png"
    df_to_png(df, out_png, title="æœ¬æœˆéŠ·å”®å ±è¡¨")

    # 2) é™„è‘—åˆ°ç¾æœ‰ Chrome
    driver = build_driver()
    ensure_web_teams_open(driver)

    # 3) ç›´é”èŠå¤© æˆ– é »é“ï¼ˆäºŒæ“‡ä¸€ï¼‰
    if CHAT_ID:
        open_chat_by_link(driver, CHAT_ID)
    else:
        open_channel_by_link(driver, CHANNEL_ID, TEAM_ID, TENANT_ID, CHANNEL_NAME)

    # 4) ä¸Šå‚³åœ–ç‰‡ + å¯é¸èªªæ˜æ–‡å­— â†’ é€å‡º
    upload_image_and_send(driver, out_png, caption="ä»¥ä¸‹ç‚ºè‡ªå‹•ç”¢å‡ºçš„è¡¨æ ¼å¿«ç…§ï¼ˆWeb Teams æ¸¬è©¦ï¼‰ğŸ“Š")

if __name__ == "__main__":
    main()


ä½¿ç”¨èªªæ˜èˆ‡å°è²¼å£«

å¼·åˆ¶ Webï¼šDeep Link å·²åŠ  &web=1ï¼Œä¸æœƒè·³æ¡Œé¢ Appã€‚

chatId å–å¾—ï¼šåœ¨è©²èŠå¤©é  location.href è£¡æœ‰ 19:...@thread.tacv2ï¼›æˆ–ç›´æ¥è¤‡è£½ç¶²å€åˆ—ã€‚

é »é“åƒæ•¸ï¼šå¾ Teams çš„ã€Œå–å¾—é€£çµåˆ°é »é“ã€è¤‡è£½å³å¯ï¼ˆè£¡é¢å°±å« channelId / groupId / tenantIdï¼‰ï¼ŒæŠŠ channelName ç”¨åŸæ¨£çµ¦å‡½å¼å³å¯ï¼Œç¨‹å¼æœƒ URL-encodeã€‚

æ‰¾ä¸åˆ° input[type=file]?

å…ˆæ‰‹å‹•é»ä¸€æ¬¡ã€ŒğŸ“ é™„åŠ ã€çœ‹çœ‹ DOM æ˜¯å¦å‡ºç¾ <input type=file>ã€‚

é–‹ DevTools ç”¨ $$('input[type=file]') æª¢æŸ¥å¯¦éš›ä½ç½®ï¼›è‹¥åœ¨ Shadow DOMï¼Œå°±è¦æ”¹ç”¨ JS å–å‡ºæˆ–æ”¹ selectorã€‚

Enter=æ›è¡Œ çš„ç§Ÿæˆ¶ï¼šè«‹æŠŠé€å‡ºæ”¹ç‚ºæ‰¾ã€Œé€å‡ºã€æŒ‰éˆ•é»æ“Šï¼ˆç¨‹å¼å·²å‚™ç”¨ï¼‰ã€‚

è¡¨æ ¼å¤ªå¯¬/å¤ªé•·ï¼šèª¿æ•´ cell_w/cell_h æˆ– dpiï¼›æˆ–æ‹†æˆå¤šå¼µåœ–ã€‚

æƒ³ã€Œè²¼ä¸Šã€åœ–ç‰‡ï¼šç€è¦½å™¨ç«¯è²¼åœ–éœ€è¦ Clipboard API èˆ‡ user gestureï¼ŒSelenium é›£åº¦è¼ƒé«˜ï¼›ç”¨ <input type=file> æœ€ç©©ã€‚

-----------------------------------------------------------------------------------------------------




å¦‚æœè¦æ’ HTMLï¼Œè¦ç”¨ JavaScript æ³¨å…¥,è«‹æä¾›æ–¹æ³•


å¯ä»¥ï¼æ€è·¯æ˜¯ã€Œå…ˆé–å®šè¨Šæ¯è¼¸å…¥æ¡†ï¼ˆcontenteditableï¼‰ï¼Œå†ç”¨ execute_script åœ¨ç€è¦½å™¨ç«¯æŠŠ HTML æ’å…¥ã€ï¼Œ
æœ€å¾Œè§¸ç™¼ input äº‹ä»¶è®“ Teams æ¥æ”¶åˆ°è®Šæ›´ã€‚ä¸‹é¢çµ¦ä½ å¯ç›´æ¥ç”¨çš„ç¯„ä¾‹ï¼ˆå« iframe æƒæèˆ‡ &web=1 å¼·åˆ¶ Web ç‰ˆï¼‰ã€‚

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from urllib.parse import quote
import time

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"  # æ”¹æˆä½ çš„ chatId

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    drv = webdriver.Chrome(service=service, options=opts)
    drv.implicitly_wait(0)
    return drv

def open_chat_by_link(driver, chat_id):
    url = f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1"
    driver.get(url)

def locate_compose_el(driver, timeout=40):
    """å˜—è©¦åœ¨ä¸»æ–‡ä»¶èˆ‡æ‰€æœ‰ iframe ä¸­æ‰¾ contenteditable è¼¸å…¥æ¡†ã€‚"""
    end = time.time() + timeout
    tried_iframes = set()

    while time.time() < end:
        # å…ˆçœ‹ä¸»æ–‡æª”
        driver.switch_to.default_content()
        els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els:
            return els[0]

        # æƒæ iframe
        iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
        for idx, f in enumerate(iframes):
            if f.id in tried_iframes:
                continue
            tried_iframes.add(f.id)
            try:
                driver.switch_to.default_content()
                driver.switch_to.frame(f)
                els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els:
                    return els[0]
            except Exception:
                continue

        time.sleep(0.3)

    raise RuntimeError("æ‰¾ä¸åˆ° Teams è¨Šæ¯è¼¸å…¥æ¡†ï¼ˆcontenteditable role=textboxï¼‰ã€‚")

def js_insert_html(driver, compose_el, html, replace=True):
    """
    ç”¨ JS æŠŠ HTML æ’å…¥åˆ°è¼¸å…¥æ¡†ä¸­ï¼š
      - replace=Trueï¼šæ¸…ç©ºå¾Œæ•´æ®µæ’å…¥
      - replace=Falseï¼šåœ¨æ¸¸æ¨™è™•/å°¾ç«¯æ’å…¥
    æœƒåŒæ™‚æ´¾é€ input/change äº‹ä»¶ï¼Œè®“ React/Teams æ¥æ”¶åˆ°æ›´æ–°ã€‚
    """
    script = r"""
(function(el, html, replace){
  try {
    el.focus();

    // é¸å–/å®šä½æ¸¸æ¨™
    const sel = window.getSelection();
    const range = document.createRange();

    if (replace) {
      // æ¸…ç©ºå…§å®¹
      while (el.firstChild) el.removeChild(el.firstChild);
      range.selectNodeContents(el);
      range.collapse(true);  // å¾é–‹é ­æ’å…¥
    } else {
      // ç½®æ–¼çµå°¾æ’å…¥ï¼ˆä¹Ÿå¯æ”¹æˆé¸å–è™•æ’å…¥ï¼‰
      range.selectNodeContents(el);
      range.collapse(false);
    }

    sel.removeAllRanges();
    sel.addRange(range);

    // å„ªå…ˆç”¨ execCommandï¼ˆè·¨ç€è¦½å™¨å° contenteditable æ”¯æ´æ€§ä»ä¸éŒ¯ï¼‰
    let ok = false;
    try {
      ok = document.execCommand('insertHTML', false, html);
    } catch(e) {}

    if (!ok) {
      // fallbackï¼šç”¨ Range + contextualFragment
      const frag = range.createContextualFragment(html);
      range.deleteContents();
      range.insertNode(frag);
      // åœ¨å°¾ç«¯è£œä¸€å€‹ <br> è®“æ¸¸æ¨™ä½ç½®æ­£å¸¸
      el.appendChild(document.createElement('br'));
    }

    // è§¸ç™¼è¼¸å…¥äº‹ä»¶ï¼Œé€šçŸ¥ React/Teams ç‹€æ…‹å·²è®Š
    el.dispatchEvent(new InputEvent('input', {bubbles:true}));
    el.dispatchEvent(new Event('change', {bubbles:true}));

    return true;
  } catch (err) {
    return String(err);
  }
})(arguments[0], arguments[1], arguments[2]);
"""
    res = driver.execute_script(script, compose_el, html, replace)
    if res is not True:
        raise RuntimeError(f"JS æ’å…¥å¤±æ•—ï¼š{res}")

def send_message(driver, compose_el):
    """é€å‡ºè¨Šæ¯ï¼ˆè‹¥ä½ çš„ç§Ÿæˆ¶ Enter=æ›è¡Œï¼Œè«‹æ”¹ç‚ºæ‰¾é€å‡ºæŒ‰éˆ•é»æ“Šï¼‰ã€‚"""
    try:
        compose_el.send_keys(Keys.ENTER)
    except Exception:
        driver.switch_to.default_content()
        btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()

def main():
    driver = build_driver()
    open_chat_by_link(driver, CHAT_ID)
    # ç­‰é é¢è¼‰å…¥ä¸»è¦å€å¡Š
    WebDriverWait(driver, 60).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[data-tid*='app-bar'], [aria-label*='èŠå¤©'], [aria-label='Chat']"))
    )

    compose = locate_compose_el(driver)

    # ä½ è¦æ³¨å…¥çš„ HTMLï¼ˆTeams æœƒæœ‰æ·¨åŒ–ï¼Œè¦‹ä¸‹æ–¹æ³¨æ„äº‹é …ï¼‰
    html = """
      <p><strong>é€±å ±</strong> â€” 2025/08/30</p>
      <ul>
        <li>å¾Œç«¯éƒ¨ç½²å®Œæˆï¼ˆ<code>v1.8.2</code>ï¼‰ã€‚</li>
        <li>å“è³ªæŒ‡æ¨™ï¼š<em>99.95% SLA</em>ã€å»¶é² P95 180msã€‚</li>
      </ul>
      <p>è©³æƒ…ï¼š<a href="https://example.com/report" target="_blank">å°ˆæ¡ˆé é¢</a></p>
      <blockquote>å‚™è¨»ï¼šä¸‹é€±é–å®š API é™æµç­–ç•¥ã€‚</blockquote>
    """

    js_insert_html(driver, compose, html, replace=True)
    time.sleep(0.5)  # è¦–ç¶²è·¯æƒ…æ³çµ¦é»ç·©è¡
    send_message(driver, compose)

if __name__ == "__main__":
    main()



é‡é»èˆ‡æ³¨æ„

å…è¨±çš„ HTML æœƒè¢« Teams ç«¯æ·¨åŒ–ï¼ˆsanitizeï¼‰ï¼Œå¸¸è¦‹å¯ä¿ç•™çš„æœ‰ï¼š<p> <br> <strong> <em> <u> <s> <code> <pre> <ul> <ol> <li> <blockquote> <a>ã€‚
å…§è¯æ¨£å¼ï¼ˆstyle="color:red"ï¼‰ã€å¤šæ•¸è¡¨æ ¼/è¤‡é›œæ¨™ç±¤ã€<img> ç­‰é€šå¸¸æœƒè¢«ç§»é™¤æˆ–æ”¹å¯«ï¼›åœ–ç‰‡è«‹èµ°æª”æ¡ˆä¸Šå‚³çš„æ–¹å¼ã€‚

è‹¥ä½ çš„ç§Ÿæˆ¶æŠŠã€ŒEnter = æ›è¡Œã€ï¼Œè«‹æŠŠ send_message() æ”¹æˆé»æ“Šã€Œé€å‡ºã€æŒ‰éˆ•ï¼ˆä¸Šé¢å·²å‚™å¥½ selectorï¼‰ã€‚

æœ‰æ™‚è¼¸å…¥æ¡†åœ¨åµŒå¥— iframe è£¡ï¼Œlocate_compose_el() å·²æœƒé€ä¸€å˜—è©¦ï¼›è‹¥ä½ é‡åˆ° Shadow DOMï¼Œéœ€è¦æ”¹ç”¨ JS ç©¿é€ Shadow root å–å¾—å…ƒç´ ï¼ˆå¯å†è£œçµ¦ä½ ï¼‰ã€‚

å¦‚æœä½ æƒ³åœ¨æ¸¸æ¨™è™•æ’å…¥è€Œéæ•´æ®µå–ä»£ï¼ŒæŠŠ replace=Falseï¼Œæˆ–æ˜¯æŠŠ range.collapse(false) æ”¹æˆç”¨ç¾æœ‰ selection çš„ getRangeAt(0) å† insertHTMLã€‚


-----------------------------------------------------------------------------------------------------------

å†è£œä¸€ç‰ˆã€ŒShadow DOM ç‰ˆæœ¬ã€æˆ–ã€ŒæŠŠ HTML èˆ‡ä¸Šå‚³åœ–ç‰‡æ··åˆï¼ˆåœ–æ–‡ä¸¦èŒ‚ï¼‰ã€çš„ç¯„ä¾‹

å¤ªå¥½äº†â€”é€™è£¡ç›´æ¥çµ¦ä½ å…©å¥—å¯ç”¨çš„ç¯„ä¾‹ï¼š

Shadow DOM ç‰ˆï¼šèƒ½åœ¨é–‹æ”¾ï¼ˆopenï¼‰Shadow DOM / iframe ä¸­æ‰¾åˆ°è¨Šæ¯è¼¸å…¥æ¡†ï¼Œä¸¦ã€Œç”¨ JS æ³¨å…¥ HTMLã€ã€‚

åœ–æ–‡ä¸¦èŒ‚ç‰ˆï¼šå…ˆæ³¨å…¥ HTMLï¼Œå†ä¸Šå‚³åœ–ç‰‡ï¼ˆç¶“ input[type=file]ï¼‰ï¼Œæœ€å¾Œé€å‡ºã€‚

å°æé†’ï¼šTeams æœƒæ·¨åŒ– HTMLï¼ˆå…è¨± <p><br><strong><em><code><pre><ul><ol><li><blockquote><a> ç­‰ï¼‰ï¼Œ<img> æœƒè¢«ç§»é™¤ï¼›è¦é¡¯ç¤ºåœ–ç‰‡è«‹ç”¨ã€Œä¸Šå‚³æª”æ¡ˆã€çš„æ–¹å¼ï¼ˆå¦‚ä¸‹ç¤ºç¯„ï¼‰ã€‚

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"  # æ›æˆä½ çš„ chatId

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    drv = webdriver.Chrome(service=service, options=opts)
    drv.implicitly_wait(0)
    return drv

def open_chat_by_link(driver, chat_id):
    driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")

def query_selector_deep(driver, selector):
    """
    åœ¨ä¸»æ–‡ä»¶ + æ‰€æœ‰ iframe ä¸­ï¼Œç”¨ open shadowRoot æ·±åº¦æŸ¥æ‰¾ç¬¬ä¸€å€‹åŒ¹é…å…ƒç´ ã€‚
    selector æ”¯æ´ '>>>â€™ éˆå¼èªæ³•ï¼ˆæ¯æ®µç‚ºä¸€å±¤ shadowHost å…§çš„ selectorï¼‰ã€‚
    ä¾‹ï¼š "mgt-person >>> div.person-container >>> button"
    """
    js = r"""
const sel = arguments[0];
function splitSel(s){ return s.split(/\s*>>>\s*/); }
function findDeep(root, parts){
  let nodes = [root];
  for (const part of parts){
    const found = [];
    for (const n of nodes){
      // åœ¨ç•¶å‰æ ¹å…§æŸ¥æ‰¾
      found.push(...n.querySelectorAll(part));
      // è‹¥ç¯€é»æœ‰ open shadow rootï¼Œç´å…¥å…¶ shadowRoot ä½œç‚ºä¸‹è¼ªæœç´¢æ ¹
      const it = n.querySelectorAll('*');
      for (const el of it){
        if (el.shadowRoot) found.push(...el.shadowRoot.querySelectorAll(part));
      }
      if (n.shadowRoot) found.push(...n.shadowRoot.querySelectorAll(part));
    }
    if (!found.length) return null;
    nodes = found;
  }
  return nodes[0] || null;
}
const parts = splitSel(sel);
let el = findDeep(document, parts);
if (!el){
  // å†æƒä¸€è¼ªæ‰€æœ‰ iframe
  const iframes = Array.from(document.querySelectorAll('iframe'));
  for (const f of iframes){
    try{
      const doc = f.contentDocument || f.contentWindow?.document;
      if (!doc) continue;
      el = findDeep(doc, parts);
      if (el) break;
    }catch(e){}
  }
}
return el;
"""
    return driver.execute_script(js, selector)

def locate_compose_box_deep(driver, timeout=40):
    end = time.time() + timeout
    while time.time() < end:
        el = query_selector_deep(driver, "[contenteditable='true'][role='textbox']")
        if el:
            return el
        time.sleep(0.3)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†ï¼ˆå« Shadow DOM/iframe æƒæï¼‰ã€‚")

def js_insert_html(driver, compose_el, html, replace=True):
    script = r"""
(function(el, html, replace){
  try{
    el.focus();
    const sel = window.getSelection();
    const range = document.createRange();

    if (replace){
      while (el.firstChild) el.removeChild(el.firstChild);
      range.selectNodeContents(el);
      range.collapse(true);
    }else{
      // ç½®æ–¼å°¾ç«¯
      range.selectNodeContents(el);
      range.collapse(false);
    }
    sel.removeAllRanges();
    sel.addRange(range);

    let ok=false;
    try{ ok = document.execCommand('insertHTML', false, html); }catch(e){}
    if (!ok){
      const frag = range.createContextualFragment(html);
      range.deleteContents();
      range.insertNode(frag);
      el.appendChild(document.createElement('br'));
    }
    el.dispatchEvent(new InputEvent('input', {bubbles:true}));
    el.dispatchEvent(new Event('change', {bubbles:true}));
    return true;
  }catch(err){ return String(err); }
})(arguments[0], arguments[1], arguments[2]);
"""
    res = driver.execute_script(script, compose_el, html, replace)
    if res is not True:
        raise RuntimeError(f"JS æ’å…¥å¤±æ•—ï¼š{res}")

def send_message(driver, compose_el):
    try:
        compose_el.send_keys(Keys.ENTER)
    except Exception:
        driver.switch_to.default_content()
        btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()

def demo_shadow_dom_html():
    driver = build_driver()
    open_chat_by_link(driver, CHAT_ID)
    WebDriverWait(driver, 60).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[data-tid*='app-bar'], [aria-label*='èŠå¤©'], [aria-label='Chat']"))
    )
    compose = locate_compose_box_deep(driver)

    html = """
      <p><strong>åœ–æª”å³å°‡ä¸Šå‚³å‰çš„èªªæ˜</strong></p>
      <ul>
        <li>æœ¬é€±é€²åº¦ 80%ï¼Œé è¨ˆä¸‹é€±å®Œæˆé©—æ”¶ã€‚</li>
        <li>å»¶é² P95ï¼š<code>180ms</code>ï¼›éŒ¯èª¤ç‡ï¼š<em>0.2%</em></li>
      </ul>
    """
    js_insert_html(driver, compose, html, replace=True)
    time.sleep(0.5)
    send_message(driver, compose)

if __name__ == "__main__":
    demo_shadow_dom_html()


-----------------------------------------------------

2) åœ–æ–‡ä¸¦èŒ‚ç‰ˆï¼šå…ˆæ³¨å…¥ HTMLï¼Œå†é€é Shadow DOM æ·±æ‰¾ <input type="file"> ä¸Šå‚³åœ–ç‰‡

import os, time
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"
IMAGE_PATH = r"C:\path\to\report.png"  # æ›æˆä½ çš„åœ–ç‰‡è·¯å¾‘

# === åŒä¸Šï¼šbuild_driver / open_chat_by_link / query_selector_deep / locate_compose_box_deep / js_insert_html / send_message ===
# ä½ å¯ä»¥å¾ä¸Šä¸€æ®µè¤‡è£½é€™äº›å‡½å¼ï¼Œé€™è£¡åªæ”¾èˆ‡ã€Œä¸Šå‚³æª”æ¡ˆã€ç›¸é—œçš„éƒ¨åˆ†

def query_selector_all_deep(driver, selector):
    js = r"""
const sel = arguments[0];
function splitSel(s){ return s.split(/\s*>>>\s*/); }
function findAllDeep(root, parts){
  let roots = [root];
  for (const part of parts){
    const next = [];
    for (const r of roots){
      next.push(...r.querySelectorAll(part));
      const it = r.querySelectorAll('*');
      for (const el of it){
        if (el.shadowRoot) next.push(...el.shadowRoot.querySelectorAll(part));
      }
      if (r.shadowRoot) next.push(...r.shadowRoot.querySelectorAll(part));
    }
    roots = next;
  }
  return roots;
}
const parts = splitSel(sel);
let out = findAllDeep(document, parts);
if (!out.length){
  const iframes = Array.from(document.querySelectorAll('iframe'));
  for (const f of iframes){
    try{
      const doc = f.contentDocument || f.contentWindow?.document;
      if (!doc) continue;
      out = findAllDeep(doc, parts);
      if (out.length) break;
    }catch(e){}
  }
}
return out;
"""
    return driver.execute_script(js, selector)

def click_attach_if_needed(driver):
    # æœ‰äº›ç‰ˆæœ¬è¦å…ˆé»ã€Œé™„åŠ /æª”æ¡ˆã€æ‰æœƒæŠŠ <input type=file> mount é€² DOM
    try:
        btn = WebDriverWait(driver, 5).until(EC.element_to_be_clickable((
            By.CSS_SELECTOR,
            "button[aria-label*='é™„åŠ '], button[aria-label*='æª”æ¡ˆ'], button[aria-label='Attach'], [data-tid*='attach']"
        )))
        btn.click()
        time.sleep(0.4)
    except Exception:
        pass

def upload_file_deep(driver, file_path):
    # å…ˆå˜—è©¦é¡¯å¼æ›è¼‰
    click_attach_if_needed(driver)

    # æ·±åº¦å°‹æ‰¾æ‰€æœ‰å¯ç”¨çš„ file inputï¼ˆåŒ…å« shadow/iframeï¼‰
    inputs = query_selector_all_deep(driver, "input[type='file']")
    if not inputs:
        raise RuntimeError("æ‰¾ä¸åˆ° input[type=file]ï¼ˆå« Shadow DOM/iframeï¼‰ã€‚è«‹å…ˆæ‰‹å‹•é»ä¸€æ¬¡ã€é™„åŠ æª”æ¡ˆã€è§€å¯Ÿ DOMã€‚")

    abs_path = os.path.abspath(file_path)
    uploaded = False
    last_err = None
    for inp in inputs:
        try:
            inp.send_keys(abs_path)
            uploaded = True
            break
        except Exception as e:
            last_err = e
            continue
    if not uploaded:
        raise RuntimeError(f"send_keys å¤±æ•—ï¼Œå¯èƒ½è¢«é®ç½©æˆ–ä¸åœ¨å¯è¦‹æ¨¹ï¼š{last_err}")

def wait_preview_ready(driver, timeout=30):
    # å˜—è©¦ç­‰åˆ°é™„ä»¶é è¦½å‡ºç¾ï¼ˆå¤šç¨®å€™é¸ï¼‰
    end = time.time() + timeout
    while time.time() < end:
        found = False
        for sel in [
            "[data-tid*='filePreview']", "[data-tid*='attachment']", "[data-tid*='imagePreview']",
            "img[alt*='é è¦½']", "img[alt*='preview']",
            "[role='listitem'] img", "[data-tid*='attachment'] [role='img']"
        ]:
            el = query_selector_deep(driver, sel)
            if el:
                found = True
                break
        if found:
            return
        time.sleep(0.4)
    # ä¸è‡´å‘½ï¼šæœ‰äº›ç§Ÿæˆ¶ä¸é¡¯ç¤ºç¸®åœ–ï¼Œä½†ä¸Šå‚³ä»æˆåŠŸ
    return

def demo_mixed_html_plus_image():
    # ===== é€™è£¡æŠŠä¸Šä¸€æ®µçš„å·¥å…·å‡½å¼è²¼ä¸Šæˆ– import =====
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    def build_driver():
        opts = webdriver.ChromeOptions()
        opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
        service = Service(CHROMEDRIVER_PATH)
        drv = webdriver.Chrome(service=service, options=opts)
        drv.implicitly_wait(0)
        return drv

    def open_chat_by_link(driver, chat_id):
        driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")

    driver = build_driver()
    open_chat_by_link(driver, CHAT_ID)
    WebDriverWait(driver, 60).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "[data-tid*='app-bar'], [aria-label*='èŠå¤©'], [aria-label='Chat']"))
    )

    # å…ˆæ’å…¥ HTMLï¼ˆèªªæ˜æ–‡å­—ï¼‰
    compose = locate_compose_box_deep(driver)
    html = """
      <p><strong>é€±å ±ï¼ˆå«åœ–ï¼‰</strong></p>
      <p>ä¸‹æ–¹é™„ä¸Šæœ€æ–°è¶¨å‹¢åœ–ï¼Œç´°ç¯€è¦‹é™„ä»¶èˆ‡å°ˆæ¡ˆé ã€‚</p>
    """
    js_insert_html(driver, compose, html, replace=True)

    # ä¸Šå‚³åœ–ç‰‡ï¼ˆæœƒé¡¯ç¤ºç‚ºè¨Šæ¯å…§é™„ä»¶/ç¸®åœ–ï¼‰
    upload_file_deep(driver, IMAGE_PATH)
    wait_preview_ready(driver, timeout=30)

    # å¯å†è£œå……ä¸€äº›ç´”æ–‡å­—èªªæ˜
    try:
        compose = locate_compose_box_deep(driver)
        compose.send_keys("ï¼ˆè‡ªå‹•ä¸Šå‚³ï¼‰KPI è¶¨å‹¢åœ–ï¼Œä¾›åƒã€‚")
    except Exception:
        pass

    # é€å‡º
    try:
        compose = locate_compose_box_deep(driver)
        compose.send_keys(Keys.ENTER)
    except Exception:
        # è‹¥ Enter=æ›è¡Œï¼Œæ”¹æŒ‰é€å‡º
        btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()

if __name__ == "__main__":
    demo_mixed_html_plus_image()

--------------------------------------------------------------------------

å¯¦æˆ°å‚™è¨»

é–‰åˆï¼ˆclosedï¼‰Shadow DOMï¼šä»¥ä¸Šæ–¹æ³•åªé©ç”¨ open shadow rootsã€‚è‹¥æŸå…ƒä»¶ä½¿ç”¨ closedï¼Œç€è¦½å™¨ç«¯è…³æœ¬ç„¡æ³•ç©¿é€ï¼›å¯æ”¹ä»¥æ¨¡æ“¬é»æ“Š UI æµç¨‹ï¼ˆè®“å®ƒæŠŠ <input type=file> mount å‡ºä¾†ï¼‰ï¼Œæˆ–èµ° CDPï¼ˆéƒ¨åˆ†æƒ…å¢ƒå¯ç©¿é€ UA shadowï¼Œä½†éæ‰€æœ‰ closed éƒ½èƒ½å–åˆ°ï¼‰ã€‚

Enter=æ›è¡Œ çš„ç§Ÿæˆ¶ï¼šæ”¹æˆæ‰¾ã€Œé€å‡ºã€æŒ‰éˆ•é»æ“Šå³å¯ã€‚

ä¸Šå‚³æª”æ¡ˆè¢«æ“‹ï¼šæŸäº›ç§Ÿæˆ¶æœƒé™åˆ¶åƒ…èƒ½å¾ã€Œé›²ç«¯ä½ç½®ã€é¸æª”ï¼Œé€™æ™‚ä»å¯æ‰¾å¾—åˆ° input[type=file]ï¼›è‹¥å®Œå…¨æ²’æœ‰ file inputï¼Œä»£è¡¨ UI èµ°è‡ªè¨‚æª”é¸å™¨ï¼Œå¿…é ˆæ”¹æˆé»æ“Šè·¯å¾‘æˆ–æ”¹èµ° Graph API ä¸Šå‚³ï¼ˆéœ€æ‡‰ç”¨æ¬Šé™ï¼‰ã€‚

ç©©å®šåº¦ï¼šTeams DOM æœƒè®Šæ›´ï¼›ä¿ç•™å¤šçµ„ selector å€™é¸ã€åŠ ä¸Šé‡è©¦/ç­‰å¾…ï¼Œæ˜¯é•·æœŸç©©å®šçš„é—œéµã€‚


----------------------------------------------------------------------------

ç¢ºèª,æˆ‘æ‰€é€£çµçš„ç¾¤çµ„è·Ÿæˆ‘è¼¸å…¥æ¡†æ‰€é€å‡ºçš„å…§å®¹æ˜¯ç›¸åŒç¾¤çµ„


ä»¥ï¼Œåšæ³•æ˜¯ã€Œåœ¨é€å‡ºå‰åš 2~3 å±¤ã€æƒ…å¢ƒé©—è­‰ã€ã€ï¼š

ç”¨ location.href è§£æå‡ºç›®å‰é é¢çš„ chatId / channelId / groupId / tenantIdï¼Œ

å†è®€å–é é¢æ¨™é ­çš„èŠå¤©å®¤/é »é“åç¨±ï¼ˆheader titleï¼‰ï¼Œ

å…¨éƒ¨èˆ‡ä½ é æœŸçš„ç›®æ¨™åšæ¯”å°ï¼Œè‹¥ä¸ä¸€è‡´å°±ä¸è¦é€å‡ºã€‚

ä¸‹é¢çµ¦ä½ ä¸€å¥—å¯ç›´æ¥ç”¨çš„é˜²å‘†ç‰ˆï¼šæ”¯æ´èŠå¤©(chat)èˆ‡é »é“(channel)ï¼Œå¤šèªç³»ã€å¤šç‰ˆæœ¬ selector å·²å…§å»ºã€‚



import re, time
from urllib.parse import urlparse, parse_qs, unquote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    drv = webdriver.Chrome(service=service, options=opts)
    drv.implicitly_wait(0)
    return drv

# ----- ç›´é”ï¼ˆå¼·åˆ¶ web=1ï¼‰ -----
def open_chat_by_id(driver, chat_id):
    driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")

def open_channel_by_link(driver, channel_id, group_id, tenant_id, channel_name):
    from urllib.parse import quote
    url = ("https://teams.microsoft.com/l/channel/"
           f"{channel_id}/{quote(channel_name)}"
           f"?groupId={group_id}&tenantId={tenant_id}&web=1")
    driver.get(url)

# ----- æŠ½å–ç›®å‰è·¯ç”±è³‡è¨Š -----
def get_route_info(driver):
    """å›å‚³ dict: kind=('chat'|'channel'|'unknown'), chatId / channelId / groupId / tenantId, url"""
    href = driver.execute_script("return location.href")
    info = {"kind":"unknown", "url":href}

    # chat: .../_#/conversations/19:xxx@thread.tacv2?ctx=chat
    m = re.search(r"/conversations/(19:[^/?#]+@thread\.tacv2)", href)
    if m:
        info.update({"kind":"chat", "chatId": m.group(1)})
        return info

    # channel: .../l/channel/<channelId>/<name>?groupId=...&tenantId=...
    if "/l/channel/" in href:
        try:
            p = urlparse(href)
            q = parse_qs(p.query)
            parts = p.path.split("/l/channel/",1)[1].split("/",1)
            channel_id = parts[0]
            info.update({
                "kind":"channel",
                "channelId": channel_id,
                "groupId": q.get("groupId",[None])[0],
                "tenantId": q.get("tenantId",[None])[0],
                "channelName": unquote(parts[1].split("?")[0]) if len(parts)>1 else None
            })
            return info
        except Exception:
            pass

    return info

# ----- è®€å–æ¨™é ­æ¨™é¡Œï¼ˆèŠå¤©å®¤/é »é“åç¨±ï¼‰ -----
def read_header_title(driver, timeout=30):
    """
    å˜—è©¦åœ¨å¤šç¨®å®¹å™¨ï¼ˆå«å¯èƒ½çš„ iframeï¼‰è£¡æ‰¾ header çš„ heading æ–‡å­—ã€‚
    """
    end = time.time() + timeout
    js = r"""
const candidates = [
  // å¸¸è¦‹ header å®¹å™¨
  "[data-tid*='chatHeader']",
  "[data-tid*='channelHeader']",
  "[aria-label='Chat']",
  "[aria-label*='èŠå¤©']",
  "[role='banner']",
  "[data-tid*='header']",
  // é€€è€Œæ±‚å…¶æ¬¡ï¼šä¸Šæ–¹ä»»ä½•å·¥å…·åˆ—å®¹å™¨
  ".ts-left-rail+div, [data-tid='topHeader']"
];
const headSel = "h1, h2, [role='heading']";
function findIn(doc){
  for(const rootSel of candidates){
    const roots = doc.querySelectorAll(rootSel);
    for(const r of roots){
      const h = r.querySelector(headSel);
      if (h && h.innerText.trim()) return h.innerText.trim();
    }
  }
  // å…¨åŸŸæƒä¸€è¼ª headingï¼Œé¸æœ€ä¸Šæ–¹ä¸”æ–‡å­—æœ€é•·è€…
  const hs = Array.from(doc.querySelectorAll(headSel)).filter(x=>x.innerText.trim().length>0);
  if (hs.length){
    hs.sort((a,b)=>a.getBoundingClientRect().top - b.getBoundingClientRect().top || b.innerText.length - a.innerText.length);
    return hs[0].innerText.trim();
  }
  return null;
}
let t = findIn(document);
if (!t){
  const ifr = Array.from(document.querySelectorAll("iframe"));
  for(const f of ifr){
    try{
      const d = f.contentDocument || f.contentWindow?.document;
      if (!d) continue;
      t = findIn(d);
      if (t) break;
    }catch(e){}
  }
}
return t;
"""
    while time.time() < end:
        title = driver.execute_script(js)
        if title: 
            return title.strip()
        time.sleep(0.3)
    return None

# ----- æ‰¾è¼¸å…¥æ¡†ï¼Œä»¥ä¾¿å¾ŒçºŒé€å‡º -----
def locate_compose(driver, timeout=40):
    end = time.time() + timeout
    while time.time() < end:
        # ä¸»æ–‡æª”å…ˆæ‰¾
        els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        # æƒ iframe
        iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                driver.switch_to.default_content()
                driver.switch_to.frame(f)
                els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els:
                    return els[0]
            except Exception:
                pass
        driver.switch_to.default_content()
        time.sleep(0.3)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†")

# ----- é©—è­‰ç›®å‰æƒ…å¢ƒæ˜¯å¦å°±æ˜¯ä½ çš„ç›®æ¨™ -----
def assert_chat_context(driver, expect_chat_id=None, expect_title=None):
    info = get_route_info(driver)
    if info.get("kind") != "chat":
        raise AssertionError(f"ç¾åœ¨ä¸åœ¨èŠå¤©è¦–åœ–ï¼š{info}")
    if expect_chat_id and info.get("chatId") != expect_chat_id:
        raise AssertionError(f"chatId ä¸ç¬¦ï¼šnow={info.get('chatId')} expect={expect_chat_id}")
    if expect_title:
        title = read_header_title(driver) or ""
        if expect_title.strip() not in title:
            raise AssertionError(f"æ¨™é¡Œä¸ç¬¦ï¼šnow_title='{title}' expect_contains='{expect_title}'")
    return info

def assert_channel_context(driver, expect_channel_id=None, expect_group_id=None, expect_tenant_id=None, expect_channel_name=None):
    info = get_route_info(driver)
    if info.get("kind") != "channel":
        raise AssertionError(f"ç¾åœ¨ä¸åœ¨é »é“è¦–åœ–ï¼š{info}")
    if expect_channel_id and info.get("channelId") != expect_channel_id:
        raise AssertionError(f"channelId ä¸ç¬¦ï¼šnow={info.get('channelId')} expect={expect_channel_id}")
    if expect_group_id and info.get("groupId") != expect_group_id:
        raise AssertionError(f"groupId ä¸ç¬¦ï¼šnow={info.get('groupId')} expect={expect_group_id}")
    if expect_tenant_id and info.get("tenantId") != expect_tenant_id:
        raise AssertionError(f"tenantId ä¸ç¬¦ï¼šnow={info.get('tenantId')} expect={expect_tenant_id}")
    if expect_channel_name:
        # ç”¨åŒ…å«æ¯”å°ï¼Œé¿å…å¤šèªç³»é™„åŠ å­—è©
        now_name = (info.get("channelName") or read_header_title(driver) or "").strip()
        if expect_channel_name.strip() not in now_name:
            raise AssertionError(f"é »é“åç¨±ä¸ç¬¦ï¼šnow='{now_name}' expect_contains='{expect_channel_name}'")
    return info

# ----- å®‰å…¨é€å‡ºï¼ˆå…ˆé©—è­‰ï¼ŒéŒ¯å°±ä¸é€ï¼‰ -----
def safe_send_text(driver, text, *, chat_id=None, chat_title_contains=None,
                   channel_id=None, group_id=None, tenant_id=None, channel_name_contains=None):
    # 1) é©—è­‰æƒ…å¢ƒ
    if chat_id or chat_title_contains:
        assert_chat_context(driver, chat_id, chat_title_contains)
    elif channel_id or group_id or tenant_id or channel_name_contains:
        assert_channel_context(driver, channel_id, group_id, tenant_id, channel_name_contains)
    else:
        raise ValueError("ä½ éœ€è¦æä¾›èŠå¤©æˆ–é »é“çš„æœŸæœ›æ¢ä»¶ä¹‹ä¸€ä¾†é©—è­‰")

    # 2) æ‰¾è¼¸å…¥æ¡†
    compose = locate_compose(driver)
    compose.click()
    # 3) è¼¸å…¥èˆ‡é€å‡ºï¼ˆè‹¥ç§Ÿæˆ¶ Enter=æ›è¡Œï¼Œæ”¹æ‰¾é€å‡ºæŒ‰éˆ•ï¼‰
    for line in text.split("\n"):
        compose.send_keys(line)
        compose.send_keys(Keys.SHIFT, Keys.ENTER)
    compose.send_keys(Keys.BACK_SPACE)
    try:
        compose.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((
            By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"
        )))
        btn.click()
    # ç°¡å–®ç¢ºèª
    WebDriverWait(driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

# ===== ä½¿ç”¨ç¯„ä¾‹ =====
if __name__ == "__main__":
    driver = build_driver()

    # A) ç™¼åˆ°ã€ŒèŠå¤©ã€ï¼šç”¨ chatId + æ¨™é¡Œé›™é‡é©—è­‰
    target_chat_id = "19:xxxxxxxxxxxxxxxx@thread.tacv2"
    open_chat_by_id(driver, target_chat_id)
    WebDriverWait(driver, 60).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='app-bar'], [aria-label='Chat'], [aria-label*='èŠå¤©']"
    )))
    safe_send_text(driver, "é€™æ˜¯ä¸€å‰‡å®‰å…¨é€å‡ºçš„æ¸¬è©¦ âœ…",
                   chat_id=target_chat_id,
                   chat_title_contains="å°ˆæ¡ˆç¾¤çµ„")   # æ¨™é¡Œå¯ç•™ç©º

    # B) ç™¼åˆ°ã€Œé »é“ã€ï¼šç”¨ channelId + groupId + tenantId + é »é“åç¨±å¤šé‡é©—è­‰
    # open_channel_by_link(driver,
    #     channel_id="19:yyyyyyyyyyyyyyyy@thread.tacv2",
    #     group_id="00000000-1111-2222-3333-444444444444",
    #     tenant_id="aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
    #     channel_name="ä¸€èˆ¬"
    # )
    # WebDriverWait(driver, 60).until(EC.presence_of_element_located((
    #     By.CSS_SELECTOR, "[data-tid*='app-bar'], [aria-label*='é »é“'], [aria-label*='Channel']"
    # )))
    # safe_send_text(driver, "é »é“è¨Šæ¯å®‰å…¨é€å‡º ğŸ“£",
    #     channel_id="19:yyyyyyyyyyyyyyyy@thread.tacv2",
    #     group_id="00000000-1111-2222-3333-444444444444",
    #     tenant_id="aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
    #     channel_name_contains="ä¸€èˆ¬"
    # )


ç‚ºä»€éº¼é€™æ¨£èƒ½ã€Œç¢ºèªã€ï¼Ÿ

è·¯ç”±å±¤ï¼šlocation.href æ˜¯ SPA çœŸå¯¦è·¯ç”±çš„å–®ä¸€äº‹å¯¦ä¾†æºã€‚

èŠå¤©ä¸€å®šå¸¶ .../conversations/<chatId>?ctx=chatã€‚

é »é“ä¸€å®šå¸¶ .../l/channel/<channelId>/...?...groupId=...&tenantId=...ã€‚
å…ˆæ¯”å°é€™äº› ID å°±èƒ½ 99% ç¢ºèªä½ æ‰€åœ¨çš„ç›®æ¨™ã€‚

UI æ¨™é ­å±¤ï¼šå†è®€å–ç•«é¢æ¨™é ­ï¼ˆèŠå¤©å®¤/é »é“åç¨±ï¼‰æ¯”å°ï¼Œé˜²æ­¢ç¨€æœ‰æƒ…æ³ä¸‹çš„è·¯ç”±æ®˜å½±æˆ–å»¶é²ã€‚

é€å‡ºå‰é˜»æ–·ï¼šè‹¥æ¯”å°å¤±æ•—ï¼Œç›´æ¥ raise errorï¼Œä¸é€è¨Šæ¯ã€‚

å¯é¸çš„ç¬¬ä¸‰å±¤ï¼ˆåŠ å¼·ç‰ˆï¼‰

é€å‡ºå‰å…ˆæ³¨å…¥ä¸€æ®µä¸é€å‡ºçš„è‰ç¨¿ï¼ˆä¾‹å¦‚åœ¨è¼¸å…¥æ¡†æš«å¡«ä¸€å€‹ GUIDï¼‰ï¼Œå†å¾ header/URL å†æ ¸å°ä¸€æ¬¡ï¼Œæœ€å¾Œæ‰é€å‡ºã€‚
é€™èƒ½é¿å…è·¯ç”±å‰›åˆ‡æ›æ™‚è¼¸å…¥æ¡†å°šå±¬æ–¼èˆŠè¦–åœ–çš„æ¥µç«¯æƒ…æ³ï¼ˆå¾ˆå°‘è¦‹ï¼‰ã€‚



--------------------------------------------------------------
ç¢ºä¿ç¶²é æ˜¯å­˜æ´»çš„ç‹€æ…‹


ä¸‹é¢çµ¦ä½ ä¸€å¥—ã€ŒWeb Teams å­˜æ´»æª¢æŸ¥ + è‡ªå‹•å¾©åŸã€çš„å¯¦ä½œã€‚æ ¸å¿ƒæƒ³æ³•æ˜¯æ¯æ¬¡è¦é€è¨Šæ¯å‰ï¼Œ
å…ˆè·‘ä¸€å€‹ ensure_alive()ï¼šåŒæ™‚æª¢æŸ¥ç€è¦½å™¨é€£ç·šã€ç›®å‰ç¶²å€æ˜¯å¦åœ¨ Teamsã€åŒæºç¶²è·¯æ˜¯å¦å¯é€šã€è¼¸å…¥æ¡†æ˜¯å¦å¯äº’å‹•ï¼›è‹¥å¤±æ•—å°±è‡ªå‹•å°å›ç›®æ¨™ Deep Linkï¼ˆå¸¶ &web=1ï¼‰ã€æˆ–é‡è¼‰ï¼Œæœ€å¾Œæ‰é€ã€‚

ä½ å¯ä»¥ç›´æ¥æŠŠå®ƒæ¥åˆ°ä½ ç¾æœ‰çš„ç™¼è¨Šæµç¨‹å‰é¢ã€‚


import os, re, time
from urllib.parse import urlparse, parse_qs, unquote, quote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import WebDriverException

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"

# ====== ä½ è‡ªå·±çš„ç›®æ¨™ï¼ˆæ“‡ä¸€ï¼‰======
TARGET_CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"  # èŠå¤©ï¼ˆå»ºè­°ç”¨ chatIdï¼‰
CHANNEL = {
    "channel_id": "19:yyyyyyyyyyyyyyyy@thread.tacv2",
    "group_id":   "00000000-1111-2222-3333-444444444444",
    "tenant_id":  "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
    "channel_name": "ä¸€èˆ¬",
}

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    drv = webdriver.Chrome(service=service, options=opts)
    drv.implicitly_wait(0)
    return drv

# ---------- ç›´é”é€£çµ ----------
def open_chat_by_id(driver, chat_id):
    driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")

def open_channel_by_link(driver, channel_id, group_id, tenant_id, channel_name):
    url = ("https://teams.microsoft.com/l/channel/"
           f"{channel_id}/{quote(channel_name)}"
           f"?groupId={group_id}&tenantId={tenant_id}&web=1")
    driver.get(url)

# ---------- åŸºç¤å·¥å…· ----------
def get_route_info(driver):
    href = driver.execute_script("return location.href")
    info = {"url": href, "kind": "unknown"}
    m = re.search(r"/conversations/(19:[^/?#]+@thread\.tacv2)", href)
    if m:
        info.update({"kind":"chat", "chatId": m.group(1)})
        return info
    if "/l/channel/" in href:
        p = urlparse(href)
        q = parse_qs(p.query)
        parts = p.path.split("/l/channel/",1)[1].split("/",1)
        info.update({
            "kind":"channel",
            "channelId": parts[0],
            "groupId": q.get("groupId",[None])[0],
            "tenantId": q.get("tenantId",[None])[0],
            "channelName": unquote(parts[1].split("?")[0]) if len(parts)>1 else None
        })
    return info

def find_compose(driver, timeout=12):
    end = time.time() + timeout
    while time.time() < end:
        # ä¸»æ–‡æª”
        els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        # iframe æƒæ
        iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                driver.switch_to.default_content()
                driver.switch_to.frame(f)
                els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els: return els[0]
            except Exception:
                pass
        driver.switch_to.default_content()
        time.sleep(0.25)
    return None

def ping_same_origin(driver, path="/_?web=1", ms_timeout=4000):
    """
    åœ¨é é¢ç«¯åšåŒæº HEAD è«‹æ±‚ï¼Œç¢ºèªç¶²è·¯ & ç§Ÿæˆ¶é€£ç·šå¯ç”¨ã€‚
    å›å‚³ dict: {"ok":bool,"status":int|None,"error":str|None}
    """
    script = r"""
const done = arguments[arguments.length - 1];
const path = arguments[0], ms_timeout = arguments[1];
const ctrl = new AbortController();
const id = setTimeout(()=>ctrl.abort(), ms_timeout);
fetch(path, {method:'HEAD', cache:'no-store', signal: ctrl.signal})
  .then(r => { clearTimeout(id); done({ok: r.ok, status: r.status}); })
  .catch(e => { clearTimeout(id); done({ok:false, status:null, error: String(e)}); });
"""
    try:
        return driver.execute_async_script(script, path, ms_timeout)
    except WebDriverException as e:
        return {"ok": False, "status": None, "error": f"exec_async_failed: {e.msg[:120]}"}

def probe_compose_interactive(driver, el):
    """
    ä¸è¼¸å‡ºã€Œæ­£åœ¨è¼¸å…¥ã€ï¼›åƒ…ç”¨ JS è¼•é»é¸ & æª¢æŸ¥å±¬æ€§/å¯ç·¨è¼¯æ€§ã€‚
    """
    script = r"""
const el = arguments[0];
try{
  const editable = el.getAttribute('contenteditable') === 'true';
  const disabled  = el.getAttribute('aria-disabled') === 'true';
  const hidden = el.offsetParent === null; // ç²—ç•¥å¯è¦‹æ€§
  // å˜—è©¦å»ºç«‹èˆ‡ç§»é™¤ä¸€å€‹é›¶å¯¬åº¦å­—å…ƒçš„å ä½ï¼Œä¸æ´¾é€ input äº‹ä»¶
  const mark = document.createElement('span');
  mark.setAttribute('data-liveness-probe', Date.now());
  mark.style.display='none';
  el.appendChild(mark);
  const attached = el.contains(mark);
  if (attached) mark.remove();
  return {editable, disabled, hidden, attached};
}catch(e){
  return {error:String(e)};
}
"""
    return driver.execute_script(script, el)

# ---------- å­˜æ´»æª¢æŸ¥ + è‡ªå‹•å¾©åŸ ----------
def ensure_alive(driver, *, target_chat_id=None, target_channel=None, max_retries=2, verbose=True):
    """
    å›å‚³ (ok:bool, info:dict)
    info æœƒé™„å¸¶æ¯ä¸€æ­¥æª¢æŸ¥çš„çµæœï¼Œä¾¿æ–¼è¨˜éŒ„ã€‚
    """
    info = {"step": []}

    # A. é©…å‹•å±¤ï¼šWebDriver æ˜¯å¦ä»é™„è‘—
    try:
        driver.execute_script("return 1")
        info["step"].append("driver_ok")
    except WebDriverException as e:
        info["step"].append(f"driver_bad:{e.msg[:120]}")
        return False, info  # é€™ç¨®é€šå¸¸æ˜¯ Chrome é—œäº†æˆ– DevTools æ–·ç·š

    # B. ç¶²åŸŸ/è·¯ç”±å±¤ï¼šæ˜¯å¦åœ¨ teams.microsoft.com & æ­£ç¢ºè¦–åœ–
    try:
        origin = driver.execute_script("return location.origin")
        href   = driver.execute_script("return location.href")
        info["origin"] = origin; info["href"] = href
    except Exception as e:
        info["step"].append(f"location_fail:{e}")
        return False, info

    if "teams.microsoft.com" not in info["origin"]:
        info["step"].append("not_on_teams_origin")
        # å˜—è©¦å°å›
        driver.get("https://teams.microsoft.com/_?web=1")
        WebDriverWait(driver, 30).until(EC.presence_of_element_located(
            (By.CSS_SELECTOR, "body")))
        # é‡æ–°å–ä¸€æ¬¡
        origin = driver.execute_script("return location.origin")
        if "teams.microsoft.com" not in origin:
            info["step"].append("redirect_back_failed")
            return False, info

    # C. åŒæº Pingï¼šç¢ºä¿ç§Ÿæˆ¶/ç¶²è·¯é€š
    ping = ping_same_origin(driver)
    info["ping"] = ping
    if not ping.get("ok", False):
        info["step"].append(f"ping_fail:{ping}")
        # ç¶²è·¯æš«æ–·æˆ– cookie éæœŸæ™‚ï¼Œé€šå¸¸é‡æ–°å°å‘åˆ°ç›®æ¨™å¯æ¢å¾©
    else:
        info["step"].append("ping_ok")

    # D. è¦–åœ–èˆ‡è¼¸å…¥æ¡†ï¼šç¢ºä¿åœ¨èŠå¤©/é »é“ï¼Œä¸”è¼¸å…¥æ¡†å¯äº’å‹•
    def goto_target():
        if target_chat_id:
            open_chat_by_id(driver, target_chat_id)
        elif target_channel:
            open_channel_by_link(driver,
                target_channel["channel_id"],
                target_channel["group_id"],
                target_channel["tenant_id"],
                target_channel["channel_name"]
            )
        else:
            driver.get("https://teams.microsoft.com/_?web=1")

    tries = 0
    while tries <= max_retries:
        route = get_route_info(driver)
        info["route"] = route
        # è‹¥æä¾›äº†ç›®æ¨™ï¼Œå°±æª¢æŸ¥æ˜¯å¦ä¸€è‡´ï¼›å¦å‰‡åªè¦èƒ½æ‰¾åˆ°å¯ç”¨è¼¸å…¥æ¡†å³å¯
        target_ok = True
        if target_chat_id and route.get("kind") == "chat":
            target_ok = (route.get("chatId") == target_chat_id)
        elif target_channel and route.get("kind") == "channel":
            target_ok = (route.get("channelId") == target_channel["channel_id"]
                        and route.get("groupId") == target_channel["group_id"]
                        and route.get("tenantId")== target_channel["tenant_id"])
        elif (target_chat_id or target_channel) and route.get("kind") == "unknown":
            target_ok = False

        el = find_compose(driver, timeout=8)
        if target_ok and el:
            probe = probe_compose_interactive(driver, el)
            info["probe"] = probe
            if probe.get("error"):
                info["step"].append(f"probe_error:{probe['error']}")
            # è¦–ç‚ºå¯äº’å‹•çš„æ¢ä»¶ï¼šeditable ä¸”é disabled ä¸”é hidden
            if probe.get("editable") and not probe.get("disabled") and not probe.get("hidden"):
                info["step"].append("compose_ready")
                return True, info

        # æœªé”æˆ â†’ å˜—è©¦å¾©åŸï¼šå°å‘ç›®æ¨™æˆ–é‡è¼‰
        tries += 1
        if verbose: print(f"[ensure_alive] recover try {tries}/{max_retries} ...")
        goto_target()
        # ç­‰å¾…ä¸»é«”è¼‰å…¥
        try:
            WebDriverWait(driver, 30).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))
        except Exception:
            pass

    info["step"].append("compose_not_ready_after_recover")
    return False, info

# ---------- ç¤ºä¾‹ï¼šå®‰å…¨ç™¼é€ ----------
def safe_send_text(driver, text):
    ok, detail = ensure_alive(driver, target_chat_id=TARGET_CHAT_ID, # æˆ–æ”¹æˆ target_channel=CHANNEL
                              max_retries=2, verbose=True)
    if not ok:
        raise RuntimeError(f"Web Teams ä¸åœ¨å­˜æ´»/æ­£ç¢ºç‹€æ…‹ï¼š{detail}")

    # çœŸæ­£é€å‡º
    el = find_compose(driver, timeout=10)
    el.click()
    for line in text.split("\n"):
        el.send_keys(line)
        el.send_keys(Keys.SHIFT, Keys.ENTER)
    el.send_keys(Keys.BACK_SPACE)
    try:
        el.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((
            By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"
        )))
        btn.click()
    WebDriverWait(driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

if __name__ == "__main__":
    driver = build_driver()
    # å»ºè­°å…ˆå°åˆ°ç›®æ¨™ï¼ˆå¯çœä¸€æ¬¡å¾©åŸï¼‰
    open_chat_by_id(driver, TARGET_CHAT_ID)  # æˆ– open_channel_by_link(...)
    WebDriverWait(driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))
    safe_send_text(driver, "é€™æ˜¯ä¸€å‰‡åœ¨ã€å­˜æ´»æª¢æŸ¥ã€å¾Œé€å‡ºçš„è¨Šæ¯ âœ…")




--------------------------------------------------------------------------------------------------------
å¦‚æœå»ç›£è½ç‰¹å®šçš„ç¾¤çµ„æœ‰æ–°çš„è¨Šæ¯,å¯ä»¥æ‹†æˆç›£è½è·Ÿé€è¨Šæ¯

watcher.pyï¼ˆç›£è½ç«¯ï¼‰

ç›´é” chat/channel

å®‰è£ MutationObserver

æ·±åº¦æŸ¥æ‰¾ï¼ˆå« iframe / open shadow rootï¼‰

å®šæœŸæ’ˆå–æ–°äº‹ä»¶

å¯è¨­å®š SELF_NAME éæ¿¾æ‰ã€Œè‡ªå·±ç™¼çš„è¨Šæ¯ã€

# watcher.py
import os, time, json, hashlib, sys
from urllib.parse import quote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"

# ======== ç›£è½ç›®æ¨™ï¼ˆæ“‡ä¸€ï¼‰========
TARGET = {
    "type": "chat",  # "chat" æˆ– "channel"
    "chat_id": "19:xxxxxxxxxxxxxxxx@thread.tacv2",
    # "channel": {
    #   "channel_id": "19:yyyyyyyyyyyyyyyy@thread.tacv2",
    #   "group_id": "00000000-1111-2222-3333-444444444444",
    #   "tenant_id": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
    #   "channel_name": "ä¸€èˆ¬",
    # }
}

SELF_NAME = None  # ä½ çš„é¡¯ç¤ºåç¨±ï¼›è‹¥è¨­å®šï¼ŒæœƒæŠŠåŒå sender çš„è¨Šæ¯è¦–ç‚ºã€Œè‡ªå·±ã€ï¼Œå¯é¸æ“‡å¿½ç•¥
POLL_INTERVAL = 2.0  # ç§’
OUTFILE = "teams_watch_log.ndjson"  # äº‹ä»¶æŒä¹…åŒ–ï¼ˆå¯é¸ï¼‰

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    d = webdriver.Chrome(service=service, options=opts)
    d.implicitly_wait(0)
    return d

def new_tab(driver):
    driver.switch_to.new_window('tab')
    return driver.current_window_handle

def goto_target(driver):
    if TARGET["type"] == "chat":
        url = f"https://teams.microsoft.com/_#/conversations/{TARGET['chat_id']}?ctx=chat&web=1"
    else:
        c = TARGET["channel"]
        url = ("https://teams.microsoft.com/l/channel/"
               f"{c['channel_id']}/{quote(c['channel_name'])}"
               f"?groupId={c['group_id']}&tenantId={c['tenant_id']}&web=1")
    driver.get(url)
    WebDriverWait(driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

def install_observer(driver):
    """
    åœ¨ï¼ˆä¸»æ–‡ä»¶ + ç¬¬ä¸€å±¤ iframes + open shadowï¼‰ä¸­å°‹æ‰¾è¨Šæ¯æ¸…å–®å®¹å™¨ï¼Œæ›ä¸Š MutationObserverã€‚
    äº‹ä»¶æœƒè¢«æ¨é€² window.__teamsEvents ä½‡åˆ—ã€‚
    """
    js = r"""
(function(){
  // è‹¥å·²å®‰è£å°±ä¸é‡è¦†
  if (window.__teamsObserverInstalled) return 'installed';
  window.__teamsObserverInstalled = true;
  window.__teamsEvents = window.__teamsEvents || [];

  function queryAllDeep(root, selector){
    const out = Array.from(root.querySelectorAll(selector));
    // èµ°é open shadow roots
    const it = root.querySelectorAll('*');
    for (const el of it){
      if (el.shadowRoot){
        out.push(...el.shadowRoot.querySelectorAll(selector));
      }
    }
    // å†æª¢æŸ¥ root è‡ªå·±çš„ shadowRoot
    if (root.shadowRoot){
      out.push(...root.shadowRoot.querySelectorAll(selector));
    }
    return out;
  }

  function findMessageList(doc){
    const sels = [
      "[data-tid*='messageList']",
      "[data-tid*='chat-message-list']",
      "[aria-label*='messages list']",
      "[aria-label*='è¨Šæ¯æ¸…å–®']",
      "[role='list']"
    ];
    for (const s of sels){
      const arr = queryAllDeep(doc, s);
      // å–çœ‹èµ·ä¾†æ¯”è¼ƒå¤§çš„é‚£å€‹
      if (arr && arr.length){
        arr.sort((a,b)=> (b.scrollHeight*b.scrollWidth) - (a.scrollHeight*a.scrollWidth));
        return arr[0];
      }
    }
    return null;
  }

  function extractText(el){
    // å„ªå…ˆæŠ“ message content å®¹å™¨
    const cand = [
      "[data-tid*='messageContent']",
      "[data-tid*='message-body']",
      "[data-tid*='messageBody']",
      "[data-tid*='text-content']",
      "[role='document']",
      ".chat-message-container"
    ];
    for (const s of cand){
      const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
      if (t && t.innerText) return t.innerText.trim();
    }
    return (el.innerText||"").trim();
  }

  function extractSender(el){
    const cand = [
      "[data-tid*='messageAuthor']",
      "[data-tid*='author-name']",
      "[data-tid*='sender']",
      "[aria-label*='said'], [aria-label*='èªª']"
    ];
    for (const s of cand){
      const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
      if (t && t.innerText) return t.innerText.trim();
      if (t && t.getAttribute && t.getAttribute('aria-label')) return t.getAttribute('aria-label');
    }
    // æœ‰äº›æ¨£å¼æŠŠä½œè€…æ”¾åœ¨åŒä¸€ group header ä¸Šï¼Œå¾€ä¸Šæ‰¾ heading
    let p = el.parentElement;
    while (p){
      const h = p.querySelector("h1, h2, [role='heading']");
      if (h && h.innerText.trim()) return h.innerText.trim();
      p = p.parentElement;
    }
    return null;
  }

  function extractTime(el){
    const cand = [
      "time[datetime]", "[data-tid*='timestamp']", "[aria-label*='AM']", "[aria-label*='PM']",
      "[aria-label*='ä¸Šåˆ']", "[aria-label*='ä¸‹åˆ']", "[data-tid*='messageTime']"
    ];
    for (const s of cand){
      const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
      if (t && t.getAttribute){
        const dt = t.getAttribute('datetime');
        if (dt) return dt;
        const al = t.getAttribute('aria-label');
        if (al) return al;
      }
      if (t && t.innerText) return t.innerText.trim();
    }
    return null;
  }

  function msgHash(sender, text, time){
    const s = JSON.stringify({sender, text, time});
    let h = 0, i, chr;
    for (i = 0; i < s.length; i++) {
      chr   = s.charCodeAt(i);
      h  = ((h << 5) - h) + chr;
      h |= 0;
    }
    return "m_" + (h >>> 0).toString(16);
  }

  function wire(doc){
    const list = findMessageList(doc);
    if (!list) return false;

    const seen = new Set();
    const liSel = "[role='listitem'], [data-tid*='message']";

    function harvest(el){
      const text = extractText(el);
      if (!text) return;
      const sender = extractSender(el);
      const timeStr = extractTime(el) || new Date().toISOString();
      const id = (el.id && el.id.length>0) ? el.id : msgHash(sender, text, timeStr);
      if (seen.has(id)) return;
      seen.add(id);

      window.__teamsEvents.push({
        id, sender, text, time: timeStr, ts: Date.now()
      });
    }

    // åˆå§‹æŠŠç›®å‰ç•«é¢å…§çš„è¨Šæ¯æŠ“ä¸€æ¬¡ï¼ˆé¿å…æ¼æ‰è¼‰å…¥æ™‚çš„æœ€å¾Œå¹¾å‰‡ï¼‰
    const items = queryAllDeep(list, liSel);
    for (const it of items){ harvest(it); }

    const mo = new MutationObserver((muts)=>{
      for (const m of muts){
        if (m.type === 'childList' && m.addedNodes && m.addedNodes.length){
          m.addedNodes.forEach(n=>{
            if (!(n instanceof Element)) return;
            if (n.matches && (n.matches(liSel))){
              harvest(n);
            }else{
              // æœ‰æ™‚å€™åŒ…ä¸€å±¤ container
              const cand = n.querySelectorAll ? n.querySelectorAll(liSel) : [];
              cand.forEach(harvest);
            }
          });
        }
      }
    });
    mo.observe(list, {childList:true, subtree:true});
    window.__teamsObserver = mo;
    return true;
  }

  // å…ˆåœ¨ä¸»æ–‡ä»¶è£ï¼Œè‹¥å¤±æ•—å†å˜—è©¦ç¬¬ä¸€å±¤ iframe
  if (wire(document)) return 'wired:main';
  const ifr = Array.from(document.querySelectorAll("iframe"));
  for (const f of ifr){
    try{
      const d = f.contentDocument || f.contentWindow?.document;
      if (d && wire(d)) return 'wired:iframe';
    }catch(e){}
  }
  return 'not_found';
})();
"""
    res = driver.execute_script(js)
    return res  # 'wired:main' / 'wired:iframe' / 'installed' / 'not_found'

def fetch_events(driver):
    js = r"""
if (!window.__teamsEvents) return [];
const out = window.__teamsEvents.slice();
window.__teamsEvents.length = 0;
return out;
"""
    return driver.execute_script(js)

def main():
    driver = build_driver()
    # å°ˆç”¨ç›£è½åˆ†é 
    tab = new_tab(driver)
    goto_target(driver)
    # ç­‰ä¸»é«”è¼‰å…¥
    WebDriverWait(driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

    # å®‰è£è§€å¯Ÿå™¨ï¼ˆå¯é‡è©¦æ•¸æ¬¡ï¼Œç›´åˆ°è¨Šæ¯æ¸…å–®å‡ºç¾ï¼‰
    wired = "not_found"
    for _ in range(10):
        wired = install_observer(driver)
        if wired != "not_found":
            break
        time.sleep(1.0)
    print(f"[watcher] observer status: {wired}")

    # æŒçºŒæ‹‰å–äº‹ä»¶
    outfp = open(OUTFILE, "a", encoding="utf-8") if OUTFILE else None
    try:
        while True:
            events = fetch_events(driver) or []
            for ev in events:
                # éæ¿¾è‡ªå·±
                if SELF_NAME and ev.get("sender") and SELF_NAME.strip() == ev["sender"].strip():
                    continue
                line = json.dumps(ev, ensure_ascii=False)
                print(line)
                if outfp:
                    outfp.write(line + "\n"); outfp.flush()
            time.sleep(POLL_INTERVAL)
    except KeyboardInterrupt:
        print("[watcher] stopped.")
    finally:
        if outfp: outfp.close()

if __name__ == "__main__":
    main()

--------------------------------------------------------------------------------------------------

sender.pyï¼ˆç™¼é€ç«¯ï¼‰

ç¨ç«‹è…³æœ¬ï¼Œä¿æœ‰ä½ ä¹‹å‰ç”¨çš„ ensure_alive() / safe_send_text() æµç¨‹å³å¯ã€‚é€™è£¡çµ¦ä¸€å€‹ç°¡åŒ–ç‰ˆï¼ˆç›´é” + æ‰¾è¼¸å…¥æ¡† + é€å‡ºï¼‰ã€‚

# sender.py
import time
from urllib.parse import quote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"  # èˆ‡ watcher ç›£è½çš„åŒä¸€ç¾¤çµ„

def build_driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    d = webdriver.Chrome(service=service, options=opts)
    d.implicitly_wait(0)
    return d

def open_chat(driver, chat_id):
    driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")
    WebDriverWait(driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

def find_compose(driver, timeout=30):
    end = time.time() + timeout
    while time.time() < end:
        # ä¸»æ–‡æª”
        els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        # æƒ iframe
        iframes = driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                driver.switch_to.default_content(); driver.switch_to.frame(f)
                els = driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els: return els[0]
            except Exception: pass
        driver.switch_to.default_content()
        time.sleep(0.2)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†")

def send_text(driver, text):
    box = find_compose(driver, 40)
    box.click()
    for line in text.split("\n"):
        box.send_keys(line)
        box.send_keys(Keys.SHIFT, Keys.ENTER)
    box.send_keys(Keys.BACK_SPACE)
    try:
        box.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()
    WebDriverWait(driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

if __name__ == "__main__":
    d = build_driver()
    open_chat(d, CHAT_ID)
    send_text(d, "é€™æ˜¯ä¸€å‰‡ç”± sender.py é€å‡ºçš„è¨Šæ¯ âœ…")

é—œéµå¯¦å‹™å»ºè­°

åˆ†é éš”é›¢ï¼šwatcher.py ä¸€å•Ÿå‹•å°± new_window('tab')ï¼ŒæŠŠç›£è½ç¶å®šåœ¨é‚£å€‹åˆ†é ï¼›sender.py å¦é–‹æˆ–ä½¿ç”¨ç¾æœ‰åˆ†é ã€‚é¿å…äº’æ¶ç„¦é»ã€‚

ç©©å®šæ€§ï¼šTeams DOM æœƒæ›´æ–°ã€‚ç›£è½ç¨‹å¼ç”¨å¤šçµ„ selector + æ·±åº¦æŸ¥æ‰¾ï¼ˆiframe + open shadow rootï¼‰ã€‚è‹¥ä½ çš„ç§Ÿæˆ¶ç”¨äº†æ›´å®¢è£½åŒ–çš„ DOMï¼Œä½ å¯ä»¥æŠŠç›£è½è…³æœ¬è£¡çš„ selector æ›æˆä½ ç’°å¢ƒæœ€ç©©çš„ï¼ˆç”¨ F12 çœ‹ data-tidï¼‰ã€‚

è‡ªç™¼è¨Šæ¯éæ¿¾ï¼šè¨­å®š SELF_NAME å°±èƒ½åœ¨ watcher ç«¯å¿½ç•¥è‡ªå·±é€å‡ºçš„è¨Šæ¯ï¼Œé¿å…å½¢æˆã€Œå›è²ã€ã€‚

æŒä¹…åŒ–èˆ‡å°æ¥ï¼šOUTFILE è¨˜æˆ NDJSONï¼›æˆ–æ”¹æˆæŠŠäº‹ä»¶ POST åˆ°ä½ çš„ webhookã€æ’é€² RabbitMQã€å¯«å…¥ SQLiteâ€¦éƒ½å¯ä»¥ã€‚

å¤šç§Ÿæˆ¶/é€¾æ™‚ï¼šå¦‚æœæœƒè¢«è¸¢å›ç™»å…¥ï¼Œç›£è½ç«¯æœƒå¤±å»å®¹å™¨ï¼›å¯ä»¥åŠ ä¸Šä½ å…ˆå‰çš„ ensure_alive() é‚£å¥—ä¿æ´»èˆ‡è‡ªå‹•å°å› Deep Linkã€‚


------------------------------------------------------------------------------------------------
sender è¨­å®šç•¶æ”¶åˆ°ç›£è½ç«¯ç‰¹å®šè¨Šæ¯æ™‚,ç™¼é€ç‰¹å®šè¨Šæ¯

å¯ä»¥ï¼ŒæŠŠã€Œç›£è½ã€å’Œã€Œè‡ªå‹•å›è¦†ã€ç”¨ä¸€å€‹è¶…ç°¡å–®çš„æœ¬æ©Ÿ webhook ä¸²èµ·ä¾†ï¼š

watcher.pyï¼ˆä½ å·²ç¶“æœ‰äº†ï¼‰åœ¨æŠ“åˆ°æ–°è¨Šæ¯äº‹ä»¶æ™‚ï¼ŒPOST åˆ° http://127.0.0.1:8765/event

sender_server.py å¸¸é§ï¼Œæ¥åˆ°äº‹ä»¶å°±ä¾è¦å‰‡æ¯”å°ä¸¦è‡ªå‹•ç™¼é€æŒ‡å®šè¨Šæ¯

é€™æ¨£å…©å€‹ç¨‹å¼å„åšå„çš„ã€ä¸æ¶åŒä¸€å€‹åˆ†é ï¼Œé‚è¼¯æ¸…æ™°ã€ä¹Ÿå¥½ç¶­è­·ã€‚
ä¸‹æ–¹çµ¦ä½ å®Œæ•´å¯ç”¨çš„ sender_server.pyï¼Œä»¥åŠæŠŠä½ ç¾æœ‰ watcher.py åŠ ä¸Š 3 è¡Œå°±èƒ½ä¸²èµ·ä¾†çš„ä¿®æ”¹ã€‚


1) sender_server.pyï¼ˆå¸¸é§çš„è‡ªå‹•å›è¦†ä¼ºæœç«¯ï¼‰

å…§å»º http.serverï¼Œä¸ç”¨è£å¥—ä»¶ã€‚æ”¶åˆ° watcher çš„äº‹ä»¶å°±æ¯”å°è¦å‰‡ â†’ ç”¨ Selenium é€è¨Šæ¯
é è¨­è¦å‰‡ç¤ºç¯„ï¼š
æ–‡å­—å« #ping â†’ å›è¦† pong
æ–‡å­—ç¬¦åˆ ^å ±è¡¨(\d{4}-\d{2}-\d{2})$ â†’ å›è¦†å¸¶æ—¥æœŸ
æ–‡å­—å« ä¸Šå‚³è¡¨æ ¼ â†’ï¼ˆç¯„ä¾‹ï¼‰å›è¦†ä¸€å¥è©±ï¼›ä½ å¯å»¶ä¼¸æˆã€Œä¸Šå‚³åœ–ç‰‡/è¡¨æ ¼ã€çš„æµç¨‹

# sender_server.py
import json, re, time, threading
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from urllib.parse import urlparse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# ===== ä½ çš„ç’°å¢ƒ =====
DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
CHAT_ID = "19:xxxxxxxxxxxxxxxx@thread.tacv2"   # ç›®æ¨™ç¾¤çµ„/èŠå¤©å®¤ï¼ˆå’Œ watcher ç›£è½çš„æ˜¯åŒä¸€å€‹ï¼‰
SELF_NAME = "ä½ çš„Teamsé¡¯ç¤ºåç¨±"                 # é˜²å›è²ï¼šå¿½ç•¥è‡ªå·±é€å‡ºçš„è¨Šæ¯ï¼ˆå»ºè­°å¡«ï¼‰

# ===== Selenium åŸºç¤ =====
_driver = None
_send_lock = threading.Lock()   # é¿å…å¤šè«‹æ±‚åŒæ™‚é€è¨Šæ¯äº’æ¶ç„¦é»

def build_driver():
    global _driver
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    _driver = webdriver.Chrome(service=service, options=opts)
    _driver.implicitly_wait(0)

def ensure_driver_ready():
    global _driver
    try:
        if _driver is None:
            build_driver()
        else:
            _driver.execute_script("return 1")
    except Exception:
        build_driver()

def open_chat(chat_id):
    _driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")
    WebDriverWait(_driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

def find_compose(timeout=30):
    end = time.time() + timeout
    while time.time() < end:
        els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        iframes = _driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                _driver.switch_to.default_content(); _driver.switch_to.frame(f)
                els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els: return els[0]
            except Exception: pass
        _driver.switch_to.default_content()
        time.sleep(0.2)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†")

def send_text(text):
    compose = find_compose(40)
    compose.click()
    for line in text.split("\n"):
        compose.send_keys(line); compose.send_keys(Keys.SHIFT, Keys.ENTER)
    compose.send_keys(Keys.BACK_SPACE)
    try:
        compose.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(_driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()
    WebDriverWait(_driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

# ===== è‡ªå‹•å›è¦†è¦å‰‡ =====
# å›å‚³ None è¡¨ç¤ºä¸å›ï¼›å›å‚³å­—ä¸²è¡¨ç¤ºè¦å›è¦†çš„å…§å®¹
_last_fire = {}  # rule_name -> last_tsï¼Œç”¨ä¾†åšå†·å»æ™‚é–“ï¼ˆé¿å…æ´—ç‰ˆï¼‰

def rule_contains_ping(ev):
    """æ–‡å­—åŒ…å« #ping â†’ å› pong"""
    txt = (ev.get("text") or "").strip()
    if "#ping" in txt:
        return "pong"
    return None

def rule_report_date(ev):
    """è¨Šæ¯=å ±è¡¨YYYY-MM-DD â†’ å›è¦†å·²æ”¶åˆ°"""
    txt = (ev.get("text") or "").strip()
    m = re.match(r"^å ±è¡¨(\d{4}-\d{2}-\d{2})$", txt)
    if m:
        d = m.group(1)
        return f"å·²æ”¶åˆ°å ±è¡¨æ—¥æœŸ {d}ï¼Œé–‹å§‹è™•ç† âœ…"
    return None

def rule_upload_hint(ev):
    """è¨Šæ¯åŒ…å« 'ä¸Šå‚³è¡¨æ ¼' â†’ å›è¦†æç¤ºï¼ˆå¯å»¶ä¼¸æˆçœŸçš„ä¸Šå‚³åœ–ç‰‡/è¡¨æ ¼ï¼‰"""
    txt = (ev.get("text") or "").strip()
    if "ä¸Šå‚³è¡¨æ ¼" in txt:
        return "å¥½çš„ï¼Œæˆ‘ä¾†ä¸Šå‚³æœ€æ–°è¡¨æ ¼å¿«ç…§ã€‚"
    return None

RULES = [
    ("contains_ping",  rule_contains_ping, 3),   # (åå­—, è¦å‰‡å‡½å¼, å†·å»ç§’æ•¸)
    ("report_date",    rule_report_date,   5),
    ("upload_hint",    rule_upload_hint,   5),
]

def apply_rules(ev):
    """ä¾åºå¥—ç”¨è¦å‰‡ï¼›ç¬¬ä¸€å€‹å‘½ä¸­çš„å°±å›è¦†ï¼ˆå¯æ”¹æˆç´¯ç©å¤šå‰‡ï¼‰"""
    sender = (ev.get("sender") or "").strip()
    if SELF_NAME and sender == SELF_NAME:
        return None  # å¿½ç•¥è‡ªå·±ï¼Œé˜²å›è²

    now = time.time()
    for name, fn, cooldown in RULES:
        # å†·å»
        last = _last_fire.get(name, 0)
        if now - last < cooldown:
            continue
        reply = fn(ev)
        if reply:
            _last_fire[name] = now
            return reply
    return None

# ===== HTTP Handler =====
class Handler(BaseHTTPRequestHandler):
    def _json(self, code, obj):
        body = json.dumps(obj, ensure_ascii=False).encode("utf-8")
        self.send_response(code)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def do_POST(self):
        if urlparse(self.path).path != "/event":
            return self._json(404, {"error":"not found"})
        try:
            length = int(self.headers.get("Content-Length", "0"))
            raw = self.rfile.read(length)
            payload = json.loads(raw.decode("utf-8"))
        except Exception as e:
            return self._json(400, {"error": f"bad json: {e}"})

        # å…è¨±å–®ä¸€äº‹ä»¶æˆ–äº‹ä»¶é™£åˆ—
        events = payload if isinstance(payload, list) else [payload]
        results = []

        for ev in events:
            try:
                reply = apply_rules(ev)
                if reply:
                    with _send_lock:
                        ensure_driver_ready()
                        open_chat(CHAT_ID)
                        send_text(reply)
                results.append({"id": ev.get("id"), "replied": bool(reply)})
            except Exception as e:
                results.append({"id": ev.get("id"), "error": str(e)})

        return self._json(200, {"ok": True, "results": results})

    def log_message(self, *args, **kwargs):
        # éœéŸ³ï¼›éœ€è¦æ™‚è‡ªè¡Œ print
        pass

if __name__ == "__main__":
    server = ThreadingHTTPServer(("127.0.0.1", 8765), Handler)
    print("sender_server listening on http://127.0.0.1:8765/event")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("sender_server stopped.")

-------------------------------------------------------------------------

2) ä¿®æ”¹ä½ çš„ watcher.pyï¼šæŠŠæ–°è¨Šæ¯ POST çµ¦ sender

åœ¨ä½ çš„ watcher.py ä¸­ï¼Œæ–°å¢ä¸€å€‹å°å·¥å…·å‡½å¼ post_to_sender()ï¼Œç„¶å¾Œåœ¨ä¸»è¿´åœˆæ’ˆåˆ°äº‹ä»¶å¾Œï¼Œé€ç­†å‘¼å«å®ƒå³å¯ã€‚

(A) æ–°å¢é€™æ®µï¼š
# æ”¾åœ¨æª”é ­å€æˆ– imports ä¹‹å¾Œ
import json, urllib.request

SENDER_ENDPOINT = "http://127.0.0.1:8765/event"  # sender_server.py ç›£è½ä½å€

def post_to_sender(event_dict):
    data = json.dumps(event_dict, ensure_ascii=False).encode("utf-8")
    req = urllib.request.Request(
        SENDER_ENDPOINT,
        data=data,
        headers={"Content-Type": "application/json; charset=utf-8"},
        method="POST"
    )
    with urllib.request.urlopen(req, timeout=5) as resp:
        resp.read()  # ä¸ä¸€å®šè¦ç”¨å›æ‡‰

(B) æŠŠä½ åŸæœ¬çš„æ‹‰äº‹ä»¶è¿´åœˆï¼Œæ”¹æˆï¼š
# æ—¢æœ‰ï¼š
# events = fetch_events(driver) or []
# for ev in events:
#     if SELF_NAME and ev.get("sender") == SELF_NAME: continue
#     line = json.dumps(ev, ensure_ascii=False)
#     print(line)
#     if outfp: outfp.write(line + "\n"); outfp.flush()

# æ”¹æˆï¼ˆä¿ç•™åŸæœ¬çš„ print/å¯«æª”ï¼Œå¦å¤–å¤š Post ä¸€æ¬¡çµ¦ senderï¼‰ï¼š
events = fetch_events(driver) or []
for ev in events:
    if SELF_NAME and (ev.get("sender") or "").strip() == SELF_NAME.strip():
        continue
    line = json.dumps(ev, ensure_ascii=False)
    print(line)                       # ä½ åŸæœ‰çš„è¼¸å‡º
    if outfp:
        outfp.write(line + "\n"); outfp.flush()
    try:
        post_to_sender(ev)            # â˜… é€šçŸ¥ sender_server
    except Exception as e:
        print(f"[watcher] post sender failed: {e}")

å…¶ä»– watcher å…§å®¹ï¼ˆå®‰è£ MutationObserverã€æŠ½å– sender/text/timeã€å»é‡ç­‰ï¼‰ç¶­æŒä¸è®Šå°±å¥½ã€‚


ä½¿ç”¨æ­¥é©Ÿï¼ˆä¸€æ¬¡æå®šï¼‰

å…ˆå•Ÿå‹• sender_server.py

python sender_server.py


ä½ æœƒçœ‹åˆ°ï¼š
sender_server listening on http://127.0.0.1:8765/event


å†å•Ÿå‹• watcher.pyï¼ˆä½ çš„ç‰ˆæœ¬ï¼Œå·²åŠ å…¥ post_to_sender èˆ‡è¿´åœˆä¿®æ”¹ï¼‰
å®ƒæœƒåœ¨ä½ æŒ‡å®šçš„ç¾¤çµ„/é »é“åˆ†é æ›ä¸Šç›£è½ï¼Œåµæ¸¬åˆ°æ–°è¨Šæ¯å°±ä¸Ÿä¸€åŒ… JSON åˆ° senderã€‚

åˆ° Teams è©¦æ‰“è¨Šæ¯ï¼š

åœ¨è©²ç¾¤çµ„è²¼ #ping â†’ sender æœƒè‡ªå‹•å› pong

è²¼ å ±è¡¨2025-08-30 â†’ æœƒå›ã€Œå·²æ”¶åˆ°å ±è¡¨æ—¥æœŸ 2025-08-30ï¼Œé–‹å§‹è™•ç† âœ…ã€

è²¼ã€Œè«‹å¹«æˆ‘ä¸Šå‚³è¡¨æ ¼ã€æˆ–åŒ…å«ã€Œä¸Šå‚³è¡¨æ ¼ã€ â†’ æœƒå›ã€Œå¥½çš„ï¼Œæˆ‘ä¾†ä¸Šå‚³æœ€æ–°è¡¨æ ¼å¿«ç…§ã€‚ã€


é‡è¦é˜²å‘†ï¼†å¯¦å‹™å»ºè­°

é˜²å›è²ï¼šå‹™å¿…è¨­å®š SELF_NAMEï¼ˆwatcher & sender éƒ½è¨­ï¼‰ï¼Œwatcher ç«¯å…ˆéæ¿¾ã€Œè‡ªå·±ã€çš„è¨Šæ¯ï¼Œsender ç«¯ä¹Ÿå†éæ¿¾ä¸€æ¬¡ã€‚

å»é‡ï¼šwatcher çš„äº‹ä»¶æœ¬ä¾†å°±ç”¨ id/hash å»é‡ï¼›sender ç«¯å†åŠ ã€Œè¦å‰‡å†·å»æ™‚é–“ã€é¿å…çŸ­æ™‚é–“é€£çºŒè§¸ç™¼ã€‚

å®‰å…¨é€å‡ºï¼šè‹¥ä½ è¦æ›´åš´è¬¹ï¼Œèƒ½æŠŠå‰é¢æˆ‘çµ¦ä½ çš„ ensure_alive() / safe_send_text() åµŒé€² send_text() å‰ï¼›åŸç†å®Œå…¨ç›¸å®¹ã€‚

å»¶ä¼¸ï¼šåœ–æ–‡å›è¦†ï¼šæŠŠå…ˆå‰ã€ŒDataFrameâ†’PNGâ†’ä¸Šå‚³ã€æˆ–ã€ŒJS æ³¨å…¥ HTML + ä¸Šå‚³åœ–ç‰‡ã€çš„å‡½å¼æ¬åˆ° sender ç«¯ï¼Œè®“ç‰¹å®šè¦å‰‡ï¼ˆä¾‹å¦‚å« #reportï¼‰è§¸ç™¼æ™‚è‡ªå‹•è·‘ã€Œç”¢åœ– + ä¸Šå‚³ã€ã€‚

å¤šç¾¤çµ„ï¼šè‹¥è¦åŒæ™‚ç›£è½å¤šç¾¤ï¼Œå»ºè­°ä¸€å€‹ watcher å°æ‡‰ä¸€å€‹ç¾¤ + ä¸€å€‹ sender è¦å‰‡é›†æœ€å–®ç´”ï¼›è¦é›†ä¸­è™•ç†ä¹Ÿè¡Œï¼Œäº‹ä»¶è£¡å¯åŠ ä¸Šç¾¤çµ„çš„ chatId è®“ sender ç«¯æ±ºå®šè¦å›å“ªå€‹ç¾¤ï¼ˆæ­¤æ™‚ send_text() å‰æ”¹æˆ open_chat(ev["chatId"])ï¼‰ã€‚


----------------------------------------------------------------------------------
å®‰è£ MutationObserver é€™å€‹åœ¨è§£è­¯ä¸€æ¬¡

ç•¶ä½ çœ‹åˆ°æˆ‘å¯«ã€Œå®‰è£ MutationObserverã€æ™‚ï¼Œå…¶å¯¦å°±æ˜¯åœ¨ç¶²é ï¼ˆWeb Teamsï¼‰è£¡æ›ä¸€å€‹DOM è®Šæ›´ç›£è½å™¨ï¼Œç›¯ä½ã€Œè¨Šæ¯åˆ—è¡¨ã€é‚£å¡Šå®¹å™¨ï¼›ä¸€æ—¦æœ‰ã€Œæ–°è¨Šæ¯ç¯€é»è¢«æ’å…¥ã€ï¼Œå°±æŠŠé—œéµè³‡æ–™ï¼ˆsender / text / time / ä¸€å€‹å»é‡ç”¨çš„ idï¼‰ä¸Ÿé€²ä¸€å€‹ä½‡åˆ—ï¼Œè®“ Python ç«¯å®šæœŸæ’ˆå‡ºä¾†ç”¨ã€‚

ä¸‹é¢ç”¨å¯ç›´æ¥è²¼é€²ç€è¦½å™¨ Console æˆ– Selenium execute_script çš„æœ€å°å¯ç”¨ç‰ˆæœ¬ï¼Œä¸¦ç©¿æ’é‡é»è§£é‡‹ã€‚

æœ€å°å¯ç”¨ç‰ˆï¼ˆé™„è¨»è§£ï¼‰

// 1) å…¨åŸŸç‹€æ…‹ï¼šé¿å…é‡è¤‡å®‰è£ï¼Œæº–å‚™äº‹ä»¶ä½‡åˆ—
if (!window.__teamsObserverInstalled) {
  window.__teamsObserverInstalled = true;
  window.__teamsEvents = [];                  // è§€æ¸¬åˆ°çš„æ–°è¨Šæ¯äº‹ä»¶éƒ½ä¸Ÿé€™è£¡
  window.__teamsSeen  = new Set();            // å»é‡ï¼ˆä¾è¨Šæ¯ id æˆ– hashï¼‰
  window.__teamsObserver = null;              // è§€æ¸¬å™¨å¯¦ä¾‹
  window.__teamsTarget = null;                // ç›®å‰è¢«è§€æ¸¬çš„è¨Šæ¯æ¸…å–®å®¹å™¨
}

/** 2) æ·±åº¦æŸ¥æ‰¾å·¥å…·ï¼šæ”¯æ´ open Shadow DOM + ç¬¬ä¸€å±¤ iframe */
function queryAllDeep(root, selector) {
  const out = Array.from(root.querySelectorAll(selector));
  const it = root.querySelectorAll('*');
  for (const el of it) if (el.shadowRoot)
    out.push(...el.shadowRoot.querySelectorAll(selector));
  if (root.shadowRoot)
    out.push(...root.shadowRoot.querySelectorAll(selector));
  return out;
}
function findInAllDocs(selector) {
  // å…ˆåœ¨ä¸»æ–‡ä»¶æ‰¾ï¼Œä¸åˆ°å†æƒç¬¬ä¸€å±¤ iframe
  let arr = queryAllDeep(document, selector);
  if (arr.length) return arr;
  for (const f of document.querySelectorAll('iframe')) {
    try {
      const d = f.contentDocument || f.contentWindow?.document;
      if (!d) continue;
      arr = queryAllDeep(d, selector);
      if (arr.length) return arr;
    } catch {}
  }
  return [];
}

/** 3) å°‹æ‰¾è¨Šæ¯æ¸…å–®å®¹å™¨ï¼ˆTeams å¤šç‰ˆæœ¬ selectorï¼Œå–æœ€å¤§é‚£å¡Šï¼‰ */
function findMessageList() {
  const cands = [
    "[data-tid*='messageList']",
    "[data-tid*='chat-message-list']",
    "[aria-label*='messages list']",
    "[aria-label*='è¨Šæ¯æ¸…å–®']",
    "[role='list']"
  ];
  for (const sel of cands) {
    const arr = findInAllDocs(sel);
    if (arr.length) {
      arr.sort((a,b)=> (b.scrollHeight*b.scrollWidth) - (a.scrollHeight*a.scrollWidth));
      return arr[0];
    }
  }
  return null;
}

/** 4) å¾è¨Šæ¯ç¯€é»èƒå–è³‡æ–™ï¼ˆsender / text / timeï¼‰ï¼Œä¸¦åšå»é‡ id */
function getText(el) {
  const cands = [
    "[data-tid*='messageContent']",
    "[data-tid*='message-body']",
    "[data-tid*='messageBody']",
    "[data-tid*='text-content']",
    "[role='document']",
    ".chat-message-container"
  ];
  for (const s of cands) {
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (t && t.innerText) return t.innerText.trim();
  }
  return (el.innerText || "").trim();
}
function getSender(el) {
  const cands = [
    "[data-tid*='messageAuthor']",
    "[data-tid*='author-name']",
    "[data-tid*='sender']",
    "[aria-label*='said']",
    "[aria-label*='èªª']"
  ];
  for (const s of cands) {
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (!t) continue;
    if (t.innerText) return t.innerText.trim();
    if (t.getAttribute && t.getAttribute('aria-label')) return t.getAttribute('aria-label');
  }
  return null;
}
function getTime(el) {
  const cands = [
    "time[datetime]",
    "[data-tid*='timestamp']",
    "[data-tid*='messageTime']"
  ];
  for (const s of cands) {
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (!t) continue;
    const dt = t.getAttribute && t.getAttribute('datetime');
    if (dt) return dt;
    if (t.innerText) return t.innerText.trim();
  }
  return new Date().toISOString();
}
function makeHash(sender, text, time) {
  const s = JSON.stringify({sender, text, time});
  let h = 0;
  for (let i=0;i<s.length;i++) { h = ((h<<5)-h) + s.charCodeAt(i); h|=0; }
  return "m_" + (h>>>0).toString(16);
}

/** 5) äº‹ä»¶æ¡æ”¶ï¼ˆåˆå§‹ + æ–°å¢ç¯€é»æ™‚ï¼‰ */
function harvest(el) {
  // åƒ…é—œæ³¨åƒè¨Šæ¯çš„ç¯€é»
  const isMsg = el.matches?.("[role='listitem'], [data-tid*='message']");
  const hasMsgChild = el.querySelector?.("[role='listitem'], [data-tid*='message']");
  if (!isMsg && !hasMsgChild) return;

  const items = isMsg ? [el] : Array.from(el.querySelectorAll("[role='listitem'], [data-tid*='message']"));
  for (const it of items) {
    const sender = getSender(it);
    const text   = getText(it);
    const time   = getTime(it);
    if (!text) continue;                           // æ²’æ–‡å­—å°±ç•¥éï¼ˆè²¼åœ–/ç´”é™„ä»¶å¯æ“´å……ï¼‰
    const id = (it.id && it.id.length>0) ? it.id : makeHash(sender, text, time);
    if (window.__teamsSeen.has(id)) continue;      // å»é‡
    window.__teamsSeen.add(id);
    window.__teamsEvents.push({ id, sender, text, time, ts: Date.now() });
  }
}

/** 6) å®‰è£ MutationObserverï¼šè§€æ¸¬ list ä¸‹ã€Œæ–°å¢å­ç¯€é»ã€ */
function installObserver() {
  // è‹¥å…ˆå‰æœ‰è§€æ¸¬å™¨ï¼Œå…ˆæ‹”é™¤
  if (window.__teamsObserver && window.__teamsTarget) {
    try { window.__teamsObserver.disconnect(); } catch {}
  }

  const list = findMessageList();
  if (!list) return 'not_found';

  // åˆå§‹æŠŠç›®å‰ç•«é¢å…§å¯è¦‹çš„è¨Šæ¯æƒä¸€è¼ªï¼Œé¿å…å‰›é–‹é æ¼æ‰æœ€å¾Œå¹¾å‰‡
  queryAllDeep(list, "[role='listitem'], [data-tid*='message']").forEach(harvest);

  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      if (m.type === 'childList' && m.addedNodes?.length) {
        m.addedNodes.forEach(n => { if (n.nodeType === 1) harvest(n); });
      }
    }
  });
  mo.observe(list, { childList: true, subtree: true });
  window.__teamsObserver = mo;
  window.__teamsTarget = list;
  return 'wired';
}

/** 7) è‡ªå‹•ä¿æ´»ï¼šSPA é‡æ–°æ¸²æŸ“æ™‚ï¼Œå®¹å™¨å¸¸è¢«æ›¿æ› â†’ é€±æœŸæ€§æª¢æŸ¥é‡æ› */
if (!window.__teamsKeepAlive) {
  window.__teamsKeepAlive = setInterval(() => {
    try {
      if (!window.__teamsTarget || !document.contains(window.__teamsTarget)) {
        installObserver();
      }
    } catch {}
  }, 1500);
}

/** 8) å°å¤– APIï¼ˆPython ç«¯æœƒç”¨åˆ°ï¼‰ */
window.TeamsWatch = {
  install: installObserver,                   // å›å‚³ 'wired' æˆ– 'not_found'
  fetch: () => { const out = window.__teamsEvents.slice(); window.__teamsEvents.length = 0; return out; },
  stop:  () => { try { window.__teamsObserver?.disconnect(); } catch{}; window.__teamsTarget=null; },
  isAlive: () => !!(window.__teamsObserver && window.__teamsTarget && document.contains(window.__teamsTarget))
};

// ç«‹å³å®‰è£ä¸€æ¬¡
TeamsWatch.install();


--------------------------------------------

é€æ®µè§£è­¯ï¼ˆä½ çœŸæ­£éœ€è¦ç†è§£çš„é»ï¼‰

å…¨åŸŸç‹€æ…‹

__teamsEventsï¼šä¸€å€‹å…ˆé€²å…ˆå‡ºçš„é™£åˆ—ï¼ˆå°±åƒ queueï¼‰ï¼›æ¯æŠ“åˆ°ä¸€å‰‡æ–°è¨Šæ¯å°± push é€²ä¾†ã€‚

__teamsSeenï¼šSet ç”¨ä¾†å»é‡ï¼ˆé¿å… DOM åè¦† patch é€ æˆé‡è¤‡äº‹ä»¶ï¼‰ã€‚

__teamsObserver / __teamsTargetï¼šè¨˜ä½ç›®å‰çš„è§€æ¸¬å™¨å’Œå®ƒç¶å®šçš„ã€Œè¨Šæ¯æ¸…å–®ã€ç¯€é»ã€‚

æ·±åº¦æŸ¥æ‰¾

Teams æœƒæŠŠå…§å®¹æ”¾åœ¨open Shadow DOM æˆ– iframe è£¡ï¼›ä¸€èˆ¬çš„ querySelectorAll çœ‹ä¸åˆ° shadowRoot è£¡çš„å…ƒç´ ï¼Œæ‰€ä»¥ç”¨ queryAllDeep æŠŠ open shadow ä¹Ÿæƒé€²å»ï¼›å¦å¤–å¤šæƒç¬¬ä¸€å±¤ iframeã€‚

æ‰¾åˆ°è¨Šæ¯æ¸…å–®å®¹å™¨

é€éå¤šçµ„ selectorï¼ˆdata-tid*='messageList'ã€[role='list']â€¦ï¼‰æ‰¾æœ€å¤§é‚£å¡Šç•¶å€™é¸ï¼ˆé€šå¸¸å°±æ˜¯è¨Šæ¯ä¸²ï¼‰ã€‚

æœƒå› ç‰ˆæœ¬/èªç³»æ”¹è®Šï¼›å¦‚æœä½ æœ‰æ›´ç©©å®šçš„ data-tidï¼Œæ”¹æˆå–®ä¸€ selector æ›´å¥½ã€‚

èƒå–è¨Šæ¯å…§å®¹

getText / getSender / getTime å¾ä¸åŒ DOM çµæ§‹æ’ˆè³‡æ–™ã€‚

å¦‚æœé‡åˆ°ç´”åœ–ç‰‡/è²¼åœ–æ²’æœ‰æ–‡å­—ï¼Œé è¨­æœƒè·³éï¼ˆä½ å¯åœ¨é€™è£¡æ“´å……å¾é™„ä»¶å¡æŠ“æª”å/æ›¿ä»£æ–‡å­—ï¼‰ã€‚

å»ºå»é‡çš„ id

å…ˆç”¨ DOM è‡ªå¸¶çš„ idï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼›å¦å‰‡ä¾ sender+text+time ç®—ä¸€å€‹ç°¡å–® hashã€‚

hash åªè¦èƒ½åœ¨çŸ­æœŸå…§é¿å…é‡è¤‡å°±å¤ äº†ï¼Œä¸æ˜¯å®‰å…¨é›œæ¹Šã€‚

å®‰è£ MutationObserver

observe(list, { childList:true, subtree:true })ï¼šåªçœ‹æ–°åŠ å…¥çš„å­ç¯€é»ï¼Œæ•ˆèƒ½å¥½ã€å¹²æ“¾å°‘ã€‚

å›å‘¼è£¡åªè™•ç† addedNodesï¼Œå°‡æ¯å€‹æ–°å¢çš„è¨Šæ¯å…ƒç´ ä¸Ÿçµ¦ harvest()ã€‚

å®‰è£å‰å…ˆåšä¸€æ¬¡åˆå§‹æƒæï¼ˆé¿å…å‰›è·³é€²é é¢æ™‚æ¼æ‰å·²æ¸²æŸ“çš„æœ€å¾Œå¹¾å‰‡ï¼‰ã€‚

ä¿æ´» / è‡ªå‹•é‡æ›

SPA é‡æ–°æ¸²æŸ“æ™‚ï¼ŒèˆŠå®¹å™¨æœƒè¢«ç§»é™¤ï¼Œè§€æ¸¬å™¨å°±å¤±æ•ˆï¼›

æ‰€ä»¥ç”¨ setInterval æ¯ 1.5s æª¢æŸ¥ __teamsTarget æ˜¯å¦ä»ç„¶åœ¨æ–‡ä»¶æ¨¹å…§ï¼Œä¸åœ¨å°±é‡è·‘ installObserver()ã€‚

å°å¤– APIï¼ˆçµ¦ Selenium ç”¨ï¼‰

TeamsWatch.install()ï¼šæ‰‹å‹•é‡æ›ã€‚

TeamsWatch.fetch()ï¼šå–èµ°ä¸¦æ¸…ç©ºäº‹ä»¶ä½‡åˆ—ï¼ˆPython æ¯ 2 ç§’æ‰“ä¸€æ¬¡å³å¯ï¼‰ã€‚

TeamsWatch.stop()ï¼šé—œé–‰è§€æ¸¬å™¨ã€‚

TeamsWatch.isAlive()ï¼šç¾åœ¨æ˜¯å¦é‚„é€£åœ¨æœ‰æ•ˆå®¹å™¨ä¸Šã€‚

----------------------------
åœ¨ Selenium ç«¯æ€éº¼ç”¨ï¼ˆå…©è¡Œå°±å¥½ï¼‰

å®‰è£ï¼ˆåªéœ€ä¸€æ¬¡ï¼›æˆ–æ¯æ¬¡åˆ‡é é¢éƒ½ä¸Ÿä¸€æ¬¡ä¹Ÿæ²’é—œä¿‚ï¼‰

driver.execute_script(JS_SNIPPET_ABOVE)  # æŠŠä¸Šé¢æ•´æ®µ JS ç•¶å­—ä¸²ä¸Ÿé€²å»

è¼ªè©¢å–äº‹ä»¶

events = driver.execute_script("return window.TeamsWatch ? TeamsWatch.fetch() : []")
# events æ˜¯ [{id, sender, text, time, ts}, ...]


å¯¦æˆ°æ³¨æ„äº‹é …

æ•ˆèƒ½ï¼šåªè§€å¯Ÿ childListï¼ˆæ–°å¢ï¼‰ï¼Œé¿å…ç›£è½å±¬æ€§/æ–‡å­—è®Šå‹•ï¼Œè² æ“”æœ€å°ã€‚

è™›æ“¬æ¸…å–®ï¼šTeams æœƒè™›æ“¬åŒ–èˆŠè¨Šæ¯ï¼ˆæ²å‹•æ™‚è¼‰å…¥/å¸è¼‰ DOMï¼‰ï¼Œæˆ‘å€‘åªé—œå¿ƒã€Œæ–°å¢çš„ã€é‚£å¹¾å‰‡ï¼Œæ‰€ä»¥æ²’å•é¡Œã€‚

èªç³»/DOM è®Šå‹•ï¼šè‹¥ä½ ç™¼ç¾æœ‰æ™‚æŠ“ä¸åˆ° sender æˆ– timeï¼Œåªè¦æŠŠ getSender/getTime çš„ selector å†è£œä¸€å…©çµ„å°±ç©©äº†ï¼ˆé–‹ DevTools çœ‹ data-tid æœ€æº–ï¼‰ã€‚

è²¼åœ–/é™„ä»¶ï¼šç¾åœ¨é è¨­ç•¥éç„¡æ–‡å­—çš„è¨Šæ¯ï¼›è‹¥è¦æŠ“é™„ä»¶äº‹ä»¶ï¼Œå¯ä»¥åœ¨ harvest() è£¡å° [data-tid*='attachment'] é¡å¤–å–è³‡è¨Šï¼ˆå¦‚æª”åï¼‰ã€‚

å›è²å•é¡Œï¼šè‡ªå‹•å›è¦†å‰ï¼Œè«‹åœ¨ Python ç«¯éæ¿¾æ‰ä½ è‡ªå·±çš„ display nameï¼ˆæˆ–åœ¨ JS è£¡å°±éæ¿¾ï¼‰ï¼Œé¿å…ã€Œè‡ªå·±è§¸ç™¼è‡ªå·±ã€ã€‚

-------------------------------------------------------------------------------------


æŠŠé€™æ®µ JS å¹«ä½ åµŒé€² watcher.py çš„ install_observer(driver)ï¼ˆç›´æ¥æ›¿æ›ï¼‰ï¼Œæˆ–åŠ ä¸Šé™„ä»¶åµæ¸¬èˆ‡æ›´ç²¾æº–çš„ selectorï¼ˆè²¼ä½ çš„ DOM ç‰‡æ®µå³å¯ï¼‰

ä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç›´æ¥æŠŠã€Œç›£è½ç«¯å¯è²¼ç”¨çš„ä¸‰å€‹å‡½å¼ã€æ‰“åŒ…çµ¦ä½ ï¼ˆinstall_observer(driver) / fetch_events(driver) / is_observer_alive(driver)ï¼Œå…§å«æˆ‘å‰›å‰›é‚£æ®µ MutationObserver JSï¼‰ï¼Œæˆ–æ˜¯å¹«ä½ æŠŠ sender è¦å‰‡æ›æˆä½ çš„é—œéµå­—æ¸…å–®ã€‚

ä½ æƒ³èµ°å“ªå€‹ï¼Ÿ

Aï¼šæˆ‘è¦ã€Œwatcher.py å¯ç›´æ¥è²¼ä¸Šç‰ˆã€

Bï¼šæˆ‘è¦æ”¹ã€Œsender è‡ªå‹•å›è¦†è¦å‰‡ã€ï¼ˆè«‹çµ¦æˆ‘é—œéµå­— â†’ å›è¦†æ–‡å­—æ¸…å–®ï¼‰

Cï¼šåŒæ™‚åš A+Bï¼ˆä¹Ÿå¯ä»¥é †ä¾¿æ”¯æ´å¤šç¾¤çµ„ chatId è·¯ç”±ï¼‰

å¤ªè®šäº†ï¼æˆ‘æŠŠ A+B+C ä¸€æ¬¡æ•´ç†å¥½ï¼Œç›´æ¥å¯ç”¨ã€‚
é‡é»ï¼šåŒä¸€å° Chromeï¼ˆ--remote-debugging-port=9992ï¼‰ã€watcher è² è²¬ç›£è½ä¸¦æŠŠäº‹ä»¶ POST åˆ° senderã€sender ä¾è¦å‰‡å›è¦†ï¼Œè€Œä¸”æ”¯æ´å¤šç¾¤çµ„/é »é“è·¯ç”±ï¼ˆå›åˆ°äº‹ä»¶çš„ä¾†æº chat/channelï¼‰ã€‚


------------------------------------------------------------------------

Aï½œwatcher.pyï¼ˆå¯åŒæ™‚ç›£è½å¤šå€‹èŠå¤©æˆ–é »é“ï¼‰

å°æ¯å€‹ç›®æ¨™é–‹ä¸€å€‹åˆ†é  â†’ å®‰è£ MutationObserverï¼ˆå« open Shadow DOMã€iframe æƒæï¼‰

é€±æœŸæŠ“äº‹ä»¶ï¼Œé™„ä¸Šè·¯ç”±è³‡è¨Šï¼ˆchatId æˆ– channelId/groupId/tenantIdï¼‰

é€åˆ° sender_server.py çš„ /eventï¼ˆä¸€æ¬¡å¯é€å¤šç­†ï¼‰

æŠŠä¸‹æ®µæ•´å€‹å­˜æˆ watcher.pyï¼Œæ”¹æ‰è¨­å®šå€å³å¯ã€‚

# watcher.py
import time, json, os, urllib.request
from urllib.parse import quote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# -------------- è¨­å®šå€ --------------
DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
SENDER_ENDPOINT = "http://127.0.0.1:8765/event"   # sender_server.py ç›£è½ä½å€
SELF_NAME = None   # ä½ çš„ Teams é¡¯ç¤ºåç¨±ï¼ˆè‹¥å¡«ï¼Œæœƒåœ¨ watcher ç«¯å…ˆéæ¿¾è‡ªå·±ï¼‰

POLL_INTERVAL = 2.0
OUTFILE = "watch_log.ndjson"  # ç•™ç©ºå‰‡ä¸å¯«æª”

# åŒæ™‚ç›£è½å¤šå€‹ç›®æ¨™ï¼štype='chat' æˆ– 'channel'
TARGETS = [
    {"type":"chat", "chat_id":"19:xxxxxxxxxxxxxxxx@thread.tacv2", "note":"å°ˆæ¡ˆç¾¤"},
    # {"type":"channel", "channel_id":"19:yyyy@thread.tacv2", "group_id":"<teamId>", "tenant_id":"<tenantId>", "channel_name":"ä¸€èˆ¬", "note":"é–‹ç™¼ç¾¤/ä¸€èˆ¬"},
]
# -----------------------------------

def _driver():
    opts = webdriver.ChromeOptions()
    opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
    service = Service(CHROMEDRIVER_PATH)
    d = webdriver.Chrome(service=service, options=opts)
    d.implicitly_wait(0)
    return d

def _goto(drv, t):
    if t["type"] == "chat":
        url = f"https://teams.microsoft.com/_#/conversations/{t['chat_id']}?ctx=chat&web=1"
    else:
        url = ("https://teams.microsoft.com/l/channel/"
               f"{t['channel_id']}/{quote(t['channel_name'])}"
               f"?groupId={t['group_id']}&tenantId={t['tenant_id']}&web=1")
    drv.get(url)
    WebDriverWait(drv, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

MUTATION_JS = r"""
// == TeamsWatch Minimal (with deep search & keepalive) ==
if (!window.__teamsObserverInstalled) {
  window.__teamsObserverInstalled = true;
  window.__teamsEvents = [];
  window.__teamsSeen = new Set();
  window.__teamsObserver = null;
  window.__teamsTarget = null;
}
function qAllDeep(root, sel){
  const out = Array.from(root.querySelectorAll(sel));
  const it = root.querySelectorAll('*');
  for (const el of it) if (el.shadowRoot) out.push(...el.shadowRoot.querySelectorAll(sel));
  if (root.shadowRoot) out.push(...root.shadowRoot.querySelectorAll(sel));
  return out;
}
function qAllDocs(sel){
  let arr = qAllDeep(document, sel);
  if (arr.length) return arr;
  for (const f of document.querySelectorAll('iframe')){
    try{
      const d = f.contentDocument || f.contentWindow?.document;
      if (!d) continue;
      arr = qAllDeep(d, sel);
      if (arr.length) return arr;
    }catch(e){}
  }
  return [];
}
function findList(){
  const cands = ["[data-tid*='messageList']","[data-tid*='chat-message-list']","[aria-label*='messages list']","[aria-label*='è¨Šæ¯æ¸…å–®']","[role='list']"];
  for (const s of cands){
    const arr = qAllDocs(s);
    if (arr.length){
      arr.sort((a,b)=> (b.scrollHeight*b.scrollWidth)-(a.scrollHeight*a.scrollWidth));
      return arr[0];
    }
  }
  return null;
}
function getText(el){
  const c = ["[data-tid*='messageContent']","[data-tid*='message-body']","[data-tid*='messageBody']","[data-tid*='text-content']","[role='document']",".chat-message-container"];
  for (const s of c){
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (t && t.innerText) return t.innerText.trim();
  }
  return (el.innerText||"").trim();
}
function getSender(el){
  const c = ["[data-tid*='messageAuthor']","[data-tid*='author-name']","[data-tid*='sender']","[aria-label*='said']","[aria-label*='èªª']"];
  for (const s of c){
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (!t) continue;
    if (t.innerText) return t.innerText.trim();
    if (t.getAttribute) {
      const al = t.getAttribute('aria-label');
      if (al) return al;
    }
  }
  return null;
}
function getTime(el){
  const c = ["time[datetime]","[data-tid*='timestamp']","[data-tid*='messageTime']"];
  for (const s of c){
    const t = el.querySelector(s) || (el.shadowRoot && el.shadowRoot.querySelector(s));
    if (!t) continue;
    const dt = t.getAttribute && t.getAttribute('datetime');
    if (dt) return dt;
    if (t.innerText) return t.innerText.trim();
  }
  return new Date().toISOString();
}
function mkHash(sender, text, time){
  const s = JSON.stringify({sender,text,time});
  let h=0; for(let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; }
  return "m_"+(h>>>0).toString(16);
}
function harvest(el){
  const isMsg = el.matches?.("[role='listitem'], [data-tid*='message']");
  const hasChild = el.querySelector?.("[role='listitem'], [data-tid*='message']");
  if (!isMsg && !hasChild) return;
  const items = isMsg ? [el] : Array.from(el.querySelectorAll("[role='listitem'], [data-tid*='message']"));
  for (const it of items){
    const text = getText(it); if (!text) continue;
    const sender = getSender(it);
    const time = getTime(it);
    const id = (it.id && it.id.length? it.id : mkHash(sender,text,time));
    if (window.__teamsSeen.has(id)) continue;
    window.__teamsSeen.add(id);
    window.__teamsEvents.push({id, sender, text, time, ts: Date.now()});
  }
}
function install(){
  if (window.__teamsObserver && window.__teamsTarget) { try{window.__teamsObserver.disconnect();}catch{} }
  const list = findList();
  if (!list) return 'not_found';
  qAllDeep(list, "[role='listitem'], [data-tid*='message']").forEach(harvest);
  const mo = new MutationObserver(muts=>{
    for (const m of muts){
      if (m.type==='childList' && m.addedNodes?.length){
        m.addedNodes.forEach(n=>{ if(n.nodeType===1) harvest(n); });
      }
    }
  });
  mo.observe(list, {childList:true, subtree:true});
  window.__teamsObserver = mo;
  window.__teamsTarget = list;
  return 'wired';
}
if (!window.__teamsKeepAlive){
  window.__teamsKeepAlive = setInterval(()=>{
    try{
      if (!window.__teamsTarget || !document.contains(window.__teamsTarget)) install();
    }catch(e){}
  }, 1500);
}
window.TeamsWatch = {
  install,
  fetch: ()=>{ const out = window.__teamsEvents.slice(); window.__teamsEvents.length=0; return out; },
  alive: ()=> !!(window.__teamsObserver && window.__teamsTarget && document.contains(window.__teamsTarget))
};
TeamsWatch.install();
"""

def _open_tab(drv):
    drv.switch_to.new_window('tab')
    return drv.current_window_handle

def _post_events(batch):
    if not batch: return
    data = json.dumps(batch, ensure_ascii=False).encode("utf-8")
    req = urllib.request.Request(
        SENDER_ENDPOINT, data=data,
        headers={"Content-Type":"application/json; charset=utf-8"},
        method="POST")
    with urllib.request.urlopen(req, timeout=5) as resp:
        resp.read()

def _route_info(drv):
    href = drv.execute_script("return location.href")
    info = {"url":href, "kind":"unknown"}
    if "/conversations/" in href:
        import re
        m = re.search(r"/conversations/(19:[^/?#]+@thread\.tacv2)", href)
        if m: info.update({"kind":"chat","chatId":m.group(1)})
    elif "/l/channel/" in href:
        from urllib.parse import urlparse, parse_qs, unquote
        p = urlparse(href); q = parse_qs(p.query)
        parts = p.path.split("/l/channel/",1)[1].split("/",1)
        info.update({"kind":"channel","channelId":parts[0],"groupId":q.get("groupId",[None])[0],
                     "tenantId":q.get("tenantId",[None])[0],
                     "channelName": unquote(parts[1].split("?")[0]) if len(parts)>1 else None})
    return info

def main():
    drv = _driver()
    handles = []
    metas = []   # æ¯å€‹åˆ†é å°æ‡‰çš„ target meta
    for t in TARGETS:
        h = _open_tab(drv)
        _goto(drv, t)
        drv.execute_script(MUTATION_JS)
        handles.append(h); metas.append(t)

    outfp = open(OUTFILE, "a", encoding="utf-8") if OUTFILE else None
    try:
        while True:
            all_events = []
            for h, meta in zip(handles, metas):
                drv.switch_to.window(h)
                # æ‹‰äº‹ä»¶ï¼ˆè‹¥ TeamsWatch ä¸åœ¨å°±é‡æ–°å®‰è£ï¼‰
                try:
                    alive = drv.execute_script("return window.TeamsWatch && TeamsWatch.alive()")
                except Exception:
                    alive = False
                if not alive:
                    try: drv.execute_script(MUTATION_JS)
                    except Exception: pass

                try:
                    evs = drv.execute_script("return window.TeamsWatch ? TeamsWatch.fetch() : []") or []
                except Exception:
                    evs = []

                # é™„ä¸Šä¾†æºè·¯ç”±è³‡è¨Š + éæ¿¾è‡ªå·±
                rinfo = _route_info(drv)
                for ev in evs:
                    if SELF_NAME and (ev.get("sender") or "").strip() == SELF_NAME.strip():
                        continue
                    ev["context"] = rinfo
                    ev["note"] = meta.get("note")
                    all_events.append(ev)

            # è¼¸å‡º/æŒä¹…åŒ–
            if all_events:
                if outfp:
                    for e in all_events:
                        outfp.write(json.dumps(e, ensure_ascii=False) + "\n")
                    outfp.flush()
                # POST çµ¦ senderï¼ˆä¸€æ¬¡é€ä¸€æ‰¹è¼ƒçœäº‹ï¼‰
                try:
                    _post_events(all_events)
                except Exception as e:
                    print(f"[watcher] post failed: {e}")

            time.sleep(POLL_INTERVAL)
    except KeyboardInterrupt:
        print("[watcher] stopped.")
    finally:
        if outfp: outfp.close()

if __name__ == "__main__":
    main()


----------------------------------------------------------------------------------------------
Bï¼‹Cï½œsender_server.pyï¼ˆè¦å‰‡åŒ–å›è¦†ï¼‹å¤šç¾¤çµ„è·¯ç”±ï¼‰

æ¥æ”¶ watcher é€ä¾†çš„äº‹ä»¶ï¼ˆå¯å–®ç­†æˆ–é™£åˆ—ï¼‰

æ”¯æ´è¦å‰‡å¼•æ“ï¼ˆcontains/regex/startswith/equalsï¼Œé™å®šä¾†æºã€å†·å»æ™‚é–“ï¼‰

æœƒä¾äº‹ä»¶çš„ context è‡ªå‹•å›åˆ°ç›¸åŒ chat æˆ– channel å†é€å‡º

å…§å»ºæ–‡æœ¬å›è¦†ï¼›ä¹Ÿæä¾›åœ–ç‰‡ä¸Šå‚³èˆ‡DataFrameâ†’PNGâ†’ä¸Šå‚³ï¼ˆå¯æŒ‰éœ€å•Ÿç”¨ï¼‰
æŠŠä¸‹æ®µå­˜æˆ sender_server.pyï¼Œæ”¹æ‰è¨­å®šå€å³å¯ã€‚

--------------------------------------------------------------------------------------------

# sender_server.py
import json, re, time, threading, os
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from urllib.parse import urlparse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# -------- è¨­å®šå€ --------
DEBUGGER_ADDRESS = "127.0.0.1:9992"
CHROMEDRIVER_PATH = "chromedriver.exe"
BIND = ("127.0.0.1", 8765)

SELF_NAME = "ä½ çš„Teamsé¡¯ç¤ºåç¨±"  # å»ºè­°å¡«ï¼Œé˜²å›è²

# ï¼ˆå¯é¸ï¼‰ä½¿ç”¨ DataFrame->PNG éœ€è¦ pandas + matplotlib
ENABLE_PANDAS_IMAGE = False
# ------------------------

# ===== Selenium åŸºç¤ =====
_driver = None
_send_lock = threading.Lock()

def _ensure_driver():
    global _driver
    try:
        if _driver is None:
            opts = webdriver.ChromeOptions()
            opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
            service = Service(CHROMEDRIVER_PATH)
            _driver = webdriver.Chrome(service=service, options=opts)
            _driver.implicitly_wait(0)
        else:
            _driver.execute_script("return 1")
    except Exception:
        opts = webdriver.ChromeOptions()
        opts.add_experimental_option("debuggerAddress", DEBUGGER_ADDRESS)
        service = Service(CHROMEDRIVER_PATH)
        _driver = webdriver.Chrome(service=service, options=opts)
        _driver.implicitly_wait(0)

def _open_chat(chat_id):
    _driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")
    WebDriverWait(_driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

def _open_channel(channel_id, group_id, tenant_id, channel_name):
    from urllib.parse import quote
    url = ("https://teams.microsoft.com/l/channel/"
           f"{channel_id}/{quote(channel_name)}"
           f"?groupId={group_id}&tenantId={tenant_id}&web=1")
    _driver.get(url)
    WebDriverWait(_driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR, "body")))

def _find_compose(timeout=40):
    end = time.time() + timeout
    while time.time() < end:
        els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        iframes = _driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                _driver.switch_to.default_content(); _driver.switch_to.frame(f)
                els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els: return els[0]
            except Exception: pass
        _driver.switch_to.default_content()
        time.sleep(0.2)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†")

def _send_text(text):
    box = _find_compose(40)
    box.click()
    for line in text.split("\n"):
        box.send_keys(line); box.send_keys(Keys.SHIFT, Keys.ENTER)
    box.send_keys(Keys.BACK_SPACE)
    try:
        box.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(_driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()
    WebDriverWait(_driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

# ===== åœ–ç‰‡ä¸Šå‚³ï¼ˆå«æ·±åº¦æŸ¥æ‰¾ï¼‰ =====
def _q_all_deep(selector):
    js = r"""
const sel = arguments[0];
function qAllDeep(root, s){
  const out = Array.from(root.querySelectorAll(s));
  const it = root.querySelectorAll('*');
  for (const el of it) if (el.shadowRoot) out.push(...el.shadowRoot.querySelectorAll(s));
  if (root.shadowRoot) out.push(...root.shadowRoot.querySelectorAll(s));
  return out;
}
function allDocs(s){
  let arr = qAllDeep(document, s);
  if (arr.length) return arr;
  for (const f of document.querySelectorAll('iframe')){
    try{
      const d = f.contentDocument || f.contentWindow?.document;
      if (!d) continue;
      arr = qAllDeep(d, s); if (arr.length) return arr;
    }catch(e){}
  }
  return [];
}
return allDocs(sel);
"""
    return _driver.execute_script(js, selector)

def _click_attach_if_needed():
    try:
      btn = WebDriverWait(_driver, 3).until(EC.element_to_be_clickable((
        By.CSS_SELECTOR, "button[aria-label*='é™„åŠ '], button[aria-label*='æª”æ¡ˆ'], button[aria-label='Attach'], [data-tid*='attach']"
      )))
      btn.click(); time.sleep(0.4)
    except Exception:
      pass

def _upload_image(path):
    _click_attach_if_needed()
    inputs = _q_all_deep("input[type='file']")
    if not inputs:
        raise RuntimeError("æ‰¾ä¸åˆ° input[type=file] ä¾›ä¸Šå‚³")
    abs_path = os.path.abspath(path)
    ok = False; last = None
    for inp in inputs:
        try:
            inp.send_keys(abs_path); ok=True; break
        except Exception as e:
            last = e
    if not ok:
        raise RuntimeError(f"file input send_keys å¤±æ•—: {last}")
    # ç­‰ç¸®åœ–ï¼ˆéå¿…è¦ï¼‰
    try:
        WebDriverWait(_driver, 15).until(EC.presence_of_element_located((
            By.CSS_SELECTOR, "[data-tid*='filePreview'], [data-tid*='attachment'], [data-tid*='imagePreview'], [role='listitem'] img"
        )))
    except Exception:
        pass

def _send_image_with_caption(path, caption=None):
    _upload_image(path)
    if caption:
        box = _find_compose(20)
        box.click(); box.send_keys(caption)
    try:
        _find_compose(5).send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(_driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"))
        )
        btn.click()

# =====ï¼ˆå¯é¸ï¼‰DataFrameâ†’PNG =====
def _df_to_png_if_enabled(df, out_png, title=None, dpi=200):
    if not ENABLE_PANDAS_IMAGE:
        raise RuntimeError("ENABLE_PANDAS_IMAGE=False")
    import pandas as pd
    import matplotlib.pyplot as plt
    n_rows, n_cols = df.shape
    cell_h, cell_w = 0.6, 2.2
    title_h = 0.6 if title else 0.2
    fig_w = max(6, n_cols*cell_w); fig_h = max(2.5, n_rows*cell_h + title_h)
    fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
    ax.axis("off")
    tbl = ax.table(cellText=df.values, colLabels=df.columns, loc='center', cellLoc='center', colLoc='center')
    tbl.auto_set_font_size(False); tbl.set_fontsize(10); tbl.scale(1, 1.25)
    for (r,c), cell in tbl.get_celld().items():
        if r==0: cell.set_text_props(weight='bold'); cell.set_facecolor("#f0f0f0")
        cell.set_edgecolor("#ccc")
    if title: ax.set_title(title, pad=10, fontsize=14, fontweight='bold')
    os.makedirs(os.path.dirname(out_png), exist_ok=True) if os.path.dirname(out_png) else None
    plt.tight_layout(); plt.savefig(out_png, bbox_inches='tight', dpi=dpi); plt.close(fig)
    return out_png

# ===== è¦å‰‡ç³»çµ± =====
# æ”¯æ´çš„åŒ¹é…æ–¹æ³•
def match_contains(text, kw):    return kw in text
def match_startswith(text, kw):  return text.startswith(kw)
def match_equals(text, kw):      return text == kw
def match_regex(text, pat):      return re.search(pat, text) is not None

# è¦å‰‡è¨­å®šï¼šä½ åªè¦æ”¹é€™è£¡
RULES = [
    # ç¯„ä¾‹ 1ï¼šå« #ping â†’ å› pong
    {"name":"ping", "when":{"contains":"#ping"}, "reply":{"text":"pong"}, "cooldown_sec":3},
    # ç¯„ä¾‹ 2ï¼šå ±è¡¨æ—¥æœŸ â†’ å‹•æ…‹å¸¶å…¥
    {"name":"report_date", "when":{"regex": r"^å ±è¡¨(\d{4}-\d{2}-\d{2})$"},
     "reply":{"text":"å·²æ”¶åˆ°å ±è¡¨æ—¥æœŸ {g1}ï¼Œé–‹å§‹è™•ç† âœ…"}, "cooldown_sec":5},
    # ç¯„ä¾‹ 3ï¼šä¸Šå‚³ç¤ºæ„åœ–ï¼ˆå›ºå®šåœ–ç‰‡ï¼‰
    # {"name":"upload_sample", "when":{"contains":"ä¸Šå‚³è¡¨æ ¼"}, "reply":{"image":"sample.png", "caption":"æœ€æ–°è¡¨æ ¼å¿«ç…§"}, "cooldown_sec":10},
]
# ä½ ä¹Ÿå¯ä»¥é™åˆ¶ä¾†æºï¼Œä¾‹å¦‚é™å®šæŸå€‹ chatIdï¼š
# åœ¨è¦å‰‡åŠ ä¸Š "only": {"chatId":"19:xxx@thread.tacv2"} æˆ– "only": {"channelId":"19:yyy@thread.tacv2"}

_last_fire = {}  # (rule_name, scope_key) -> last_ts

def _scope_key(ctx):
    if ctx.get("kind")=="chat": return ("chat", ctx.get("chatId"))
    if ctx.get("kind")=="channel": return ("channel", ctx.get("channelId"), ctx.get("groupId"), ctx.get("tenantId"))
    return ("unknown",)

def _apply_rule(ev, rule):
    sender = (ev.get("sender") or "").strip()
    if SELF_NAME and sender == SELF_NAME:       # é˜²å›è²
        return None

    ctx = ev.get("context") or {}
    only = rule.get("only")
    if only:
        # åš´æ ¼æ¯”å°é™å®šä¾†æº
        for k,v in only.items():
            if ctx.get(k) != v: return None

    text = (ev.get("text") or "")
    cond = rule.get("when", {})
    ok = False; match_groups = []
    if "contains" in cond: ok = match_contains(text, cond["contains"])
    elif "startswith" in cond: ok = match_startswith(text, cond["startswith"])
    elif "equals" in cond: ok = match_equals(text, cond["equals"])
    elif "regex" in cond:
        m = re.search(cond["regex"], text)
        ok = m is not None
        if m: match_groups = [m.group(i) for i in range(1, m.lastindex+1)] if m.lastindex else []
    if not ok: return None

    # å†·å»æ™‚é–“ï¼ˆä»¥ rule + ä¾†æºç‚ºä½œç”¨åŸŸï¼‰
    scope = _scope_key(ctx)
    key = (rule["name"], scope)
    now = time.time()
    if now - _last_fire.get(key, 0) < rule.get("cooldown_sec", 0):
        return None
    _last_fire[key] = now

    # ç”¢ç”Ÿå›è¦†
    rep = rule.get("reply", {})
    if "text" in rep:
        msg = rep["text"]
        # æ”¯æ´ {g1}..{gN} æ³¨å…¥ regex ç¾¤çµ„
        for i, g in enumerate(match_groups, start=1):
            msg = msg.replace(f"{ { } }".replace(" ", f"g{i}"), g)  # trick: avoid f-string confusion
        return {"type":"text", "text": msg}
    if "image" in rep:
        return {"type":"image", "path": rep["image"], "caption": rep.get("caption")}
    if "df_image" in rep:
        # éœ€è¦ä½ åœ¨å‹•ä½œè£¡çµ„ dfï¼›é€™è£¡åªæ¼”ç¤ºæ¨£æ¿
        return {"type":"df_image", "title": rep.get("title","å ±è¡¨"), "outfile":rep.get("outfile","out/table.png")}
    return None

def _act_reply(ctx, action):
    # åˆ‡åˆ°ä¾†æº chat/channel
    if ctx.get("kind")=="chat" and ctx.get("chatId"):
        _open_chat(ctx["chatId"])
    elif ctx.get("kind")=="channel":
        _open_channel(ctx["channelId"], ctx["groupId"], ctx["tenantId"], ctx.get("channelName") or "ä¸€èˆ¬")
    else:
        raise RuntimeError(f"unknown context: {ctx}")

    t = action["type"]
    if t=="text":
        _send_text(action["text"])
    elif t=="image":
        _send_image_with_caption(action["path"], action.get("caption"))
    elif t=="df_image":
        if not ENABLE_PANDAS_IMAGE:
            _send_text("(æç¤º) å°šæœªå•Ÿç”¨ DataFrameâ†’PNG åŠŸèƒ½ã€‚")
            return
        import pandas as pd
        df = pd.DataFrame({"ç”¢å“":["A","B","C"],"éŠ·é‡":[12,18,9],"é€€è²¨ç‡":[0.5,0.9,0.2]})
        png = _df_to_png_if_enabled(df, action.get("outfile","out/table.png"), title=action.get("title"))
        _send_image_with_caption(png, caption=action.get("title"))

# ===== HTTP Server =====
class Handler(BaseHTTPRequestHandler):
    def _json(self, code, obj):
        body = json.dumps(obj, ensure_ascii=False).encode("utf-8")
        self.send_response(code); self.send_header("Content-Type","application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body))); self.end_headers()
        self.wfile.write(body)

    def do_POST(self):
        if urlparse(self.path).path != "/event":
            return self._json(404, {"error":"not found"})
        try:
            n = int(self.headers.get("Content-Length","0")); raw = self.rfile.read(n)
            payload = json.loads(raw.decode("utf-8"))
        except Exception as e:
            return self._json(400, {"error": f"bad json: {e}"})

        events = payload if isinstance(payload, list) else [payload]
        results = []
        for ev in events:
            try:
                ctx = ev.get("context") or {}
                action = None
                for rule in RULES:
                    action = _apply_rule(ev, rule)
                    if action: break
                if action:
                    with _send_lock:
                        _ensure_driver()
                        _act_reply(ctx, action)
                    results.append({"id": ev.get("id"), "replied": True})
                else:
                    results.append({"id": ev.get("id"), "replied": False})
            except Exception as e:
                results.append({"id": ev.get("id"), "error": str(e)})

        return self._json(200, {"ok": True, "results": results})

    def log_message(self, *args, **kwargs):
        pass

if __name__ == "__main__":
    server = ThreadingHTTPServer(BIND, Handler)
    print(f"sender_server listening on http://{BIND[0]}:{BIND[1]}/event")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("sender_server stopped.")
-------------------------------------------------------------------------------

ä½¿ç”¨æ–¹å¼ï¼ˆä¸€æ­¥ä¸€æ­¥ï¼‰

å…ˆå•Ÿ sender_server.py
python sender_server.py

é¡¯ç¤ºï¼šlistening on http://127.0.0.1:8765/event

å†å•Ÿ watcher.py
python watcher.py

å®ƒæœƒç‚º TARGETS ä¸­æ¯å€‹ç›®æ¨™é–‹åˆ†é ã€å®‰è£ç›£è½ï¼ŒæŠ“åˆ°æ–°è¨Šæ¯å°±é€çµ¦ senderã€‚

æ¸¬è©¦è¦å‰‡ï¼ˆé è¨­ï¼‰

åœ¨ä»»ä½•è¢«ç›£è½çš„ç¾¤çµ„/é »é“è¼¸å…¥ #ping â†’ æœƒå› pong

è¼¸å…¥ å ±è¡¨2025-08-30 â†’ æœƒå› å·²æ”¶åˆ°å ±è¡¨æ—¥æœŸ 2025-08-30ï¼Œé–‹å§‹è™•ç† âœ…


å®¢è£½åŒ–è¦é»

åŠ /æ”¹è¦å‰‡ï¼šåœ¨ sender_server.py çš„ RULES è£¡æ–°å¢ï¼š

when ç”¨ contains / startswith / equals / regex å…¶ä¸€

å¯åŠ  "only": {"chatId":"19:...@thread.tacv2"} é™å®šæŸç¾¤

å›è¦†å¯ {"text": "..."} æˆ– {"image":"path", "caption":"..."}

å¤šç¾¤çµ„è·¯ç”±ï¼šä¸ç”¨æ”¹ï¼›watcher æœƒæŠŠ context å¸¶ä¸Šä¾†ï¼Œsender æœƒå›åˆ°åŒä¸€å€‹ chat/channelã€‚

è¡¨æ ¼åœ–ç‰‡ï¼šæŠŠ ENABLE_PANDAS_IMAGE=Trueï¼Œå®‰è£ pandasã€matplotlib å¾Œå³å¯ä½¿ç”¨ df_image å‹•ä½œï¼ˆä¸Šä¾‹å·²å…§å»ºæ¨£æ¿ï¼‰ã€‚



--------------------------------------------------------------------------------

ç‚ºäº†æŠŠé€™å¥—ã€Œç›£è½ï¼‹è‡ªå‹•å›è¦†ã€ç”¨å¾—æ›´ç©©ã€ä¹Ÿæ›´å¥½ç¶­è­·ï¼Œçµ¦ä½ ä¸€å€‹ç²¾ç°¡çš„ã€Œä¸Šç·šåŒ–æ¸…å–®ã€â€”ä½ æŒ‘è¦å“ªå¹¾é …ï¼Œæˆ‘å°±ç›´æ¥ç”Ÿæª”çµ¦ä½ ï¼š

è¨­å®šæª”å¤–ç½®ï¼ˆconfig.yamlï¼‰

æŠŠ TARGETSã€RULESã€SELF_NAME éƒ½ç§»å‡ºç¨‹å¼ï¼Œå…æ”¹ç¢¼å°±èƒ½èª¿æ•´ã€‚

ä¾‹ï¼š
self_name: "ä½ çš„Teamsé¡¯ç¤ºåç¨±"
targets:
  - type: chat
    chat_id: "19:xxxxxxxx@thread.tacv2"
    note: "å°ˆæ¡ˆç¾¤"
rules:
  - name: ping
    when: { contains: "#ping" }
    reply: { text: "pong" }
    cooldown_sec: 3

å•Ÿå‹•è…³æœ¬ & æ’ç¨‹

start_sender.bat / start_watcher.batï¼ˆWindows ä¸€éµå•Ÿå‹•ï¼‰

é™„ Task Scheduler çš„ .xml ç¯„æœ¬ï¼šé–‹æ©Ÿè‡ªå‹•è·‘ã€æ„å¤–çµæŸè‡ªå‹•é‡å•Ÿã€‚

æ—¥èªŒèˆ‡å¯è§€æ¸¬æ€§

logs/*.ndjson æ»¾å‹•æ—¥èªŒï¼ˆwatcher eventã€sender å‹•ä½œã€éŒ¯èª¤ï¼‰ã€‚

å¿ƒè·³æª¢æŸ¥ï¼ˆæ¯ N åˆ†é˜è‡ªæˆ‘å›å ±åˆ°æœ¬æ©Ÿ/ä½ æŒ‡å®š webhookï¼‰ã€‚

å®‰å…¨èˆ‡é˜²å‘†

åš´æ ¼ã€Œä¾†æºç™½åå–®ã€ï¼ˆåƒ…å›ç‰¹å®š chatId/channelIdï¼‰ã€‚

é›™å±¤é˜²å›è²ï¼ˆwatcherï¼‹sender éƒ½éæ¿¾ SELF_NAMEï¼‰ã€‚

Regex æ²™ç›’ï¼‹å†·å»æ™‚é–“ï¼ˆå·²å…§å»ºï¼Œå¯ä¾è¦å‰‡ç´°èª¿ï¼‰ã€‚

é€²éšåŠŸèƒ½ï¼ˆå¯é¸ï¼‰

è‡ªå‹•ç”¢åœ–ï¼ˆDataFrameâ†’PNGï¼‰å›è²¼å ±è¡¨ã€‚

æŒ‡ä»¤èœå–®ï¼ˆè¼¸å…¥ #help å›å‚³æ”¯æ´çš„é—œéµå­—åˆ—è¡¨ï¼‰ã€‚

å¤šç¾¤è·¯ç”±å ±è¡¨ï¼ˆsender ç«¯å½™æ•´ä¸Šä¸€å°æ™‚è§¸ç™¼çµ±è¨ˆï¼‰ã€‚

ä½ å‘Šè¨´æˆ‘è¦ã€1/2/3/4/5ã€‘å“ªå¹¾é …ï¼Œæˆ‘å°±ç›´æ¥æŠŠå°æ‡‰çš„æª”æ¡ˆèˆ‡æ¨£æ¿è²¼çµ¦ä½ ï¼ˆå« batã€xmlã€yaml èˆ‡æœ€å°æ”¹å‹•ç¨‹å¼æ®µè½ï¼‰ï¼Œä¸€æ¬¡åˆ°ä½ã€‚


--------------------------------------------------------------------------------
æ²’å•é¡Œï¼æˆ‘æŠŠ 1â€“5 å…¨éƒ¨æ‰“åŒ…æˆã€Œå¯è¨­å®šã€å¯é•·æœŸåŸ·è¡Œã€çš„ä¸€å¥—å°ˆæ¡ˆæ¨£æ¿ã€‚
ä½ åªè¦æŠŠä¸‹é¢æª”æ¡ˆé€ä¸€å­˜æˆåŒä¸€å€‹è³‡æ–™å¤¾ï¼ˆä¾‹å¦‚ teams-bot/ï¼‰ï¼Œæ”¹ config.yaml åƒæ•¸å¾Œç›´æ¥åŸ·è¡Œå³å¯ã€‚


å°ˆæ¡ˆçµæ§‹ï¼ˆå»ºè­°ï¼‰
teams-bot/
â”œâ”€ config.yaml              # â‘  è¨­å®šæª”ï¼ˆä¹Ÿæ”¯æ´ config.jsonï¼‰
â”œâ”€ sender_server.py         # â‘¡ è‡ªå‹•å›è¦†ä¼ºæœå™¨ï¼ˆè¦å‰‡å¼•æ“ / å¤šç¾¤è·¯ç”± / é€²éšåŠŸèƒ½ï¼‰
â”œâ”€ watcher.py               # â‘¡ ç›£è½ç«¯ï¼ˆå¤šåˆ†é ç›£è½ + é€äº‹ä»¶åˆ° senderï¼‰
â”œâ”€ start_sender.bat         # â‘¡ ä¸€éµå•Ÿå‹•ï¼ˆWindowsï¼‰
â”œâ”€ start_watcher.bat        # â‘¡ ä¸€éµå•Ÿå‹•ï¼ˆWindowsï¼‰
â”œâ”€ task_sender.xml          # â‘¡ é–‹æ©Ÿè‡ªå‹•è·‘ï¼ˆæ’ç¨‹å™¨ XMLï¼‰
â”œâ”€ task_watcher.xml         # â‘¡ é–‹æ©Ÿè‡ªå‹•è·‘ï¼ˆæ’ç¨‹å™¨ XMLï¼‰
â”œâ”€ logs/                    # â‘¢ æ—¥èªŒè³‡æ–™å¤¾ï¼ˆNDJSONï¼‰
â””â”€ out/                     # â‘¤ ç”¢åœ–è¼¸å‡ºè³‡æ–™å¤¾ï¼ˆå¯é¸ï¼‰


â‘  è¨­å®šæª”ï¼ˆconfig.yamlï¼‰

ç„¡å¤–éƒ¨ä¾è³´ï¼šè‹¥ä½ ç’°å¢ƒä¸èƒ½è£å¥—ä»¶ï¼Œå…©å€‹ç¨‹å¼éƒ½æœƒè‡ªå‹•æ”¹è®€ config.jsonã€‚è¦ç”¨ YAML çš„è©±å¯ pip install pyyamlï¼ˆé¸æ“‡æ€§ï¼‰ã€‚
# config.yaml
self_name: "ä½ çš„Teamsé¡¯ç¤ºåç¨±"   # ç”¨ä¾†éæ¿¾è‡ªå·±çš„è¨Šæ¯ï¼Œå¼·çƒˆå»ºè­°å¡«

logging:
  dir: "logs"
  watcher_event_file: "watcher_events.ndjson"
  sender_action_file: "sender_actions.ndjson"
  rotate_mb: 10        # æª”æ¡ˆè¶…é N MB è‡ªå‹•åˆ‡æª”ï¼ˆç°¡æ˜“ç‰ˆï¼‰

watcher:
  debugger_address: "127.0.0.1:9992"
  chromedriver_path: "chromedriver.exe"
  poll_interval_sec: 2.0
  sender_endpoint: "http://127.0.0.1:8765/event"
  targets:
    - type: "chat"
      chat_id: "19:xxxxxxxxxxxxxxxx@thread.tacv2"
      note: "å°ˆæ¡ˆç¾¤"
    # - type: "channel"
    #   channel_id: "19:yyyyyyyyyyyyyyyy@thread.tacv2"
    #   channel_name: "ä¸€èˆ¬"
    #   group_id: "00000000-1111-2222-3333-444444444444"
    #   tenant_id: "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
    #   note: "é–‹ç™¼ç¾¤/ä¸€èˆ¬"

sender:
  bind_host: "127.0.0.1"
  bind_port: 8765
  debugger_address: "127.0.0.1:9992"
  chromedriver_path: "chromedriver.exe"

  # â‘£ å®‰å…¨ç™½åå–®ï¼ˆå¼·çƒˆå»ºè­°è‡³å°‘é–‹å•Ÿä½ è¦å›è¦†çš„ chat/channelï¼‰
  whitelist:
    chats: ["19:xxxxxxxxxxxxxxxx@thread.tacv2"]
    channels:
      - channel_id: "19:yyyyyyyyyyyyyyyy@thread.tacv2"
        group_id: "00000000-1111-2222-3333-444444444444"
        tenant_id: "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"

  # â‘¢ å¿ƒè·³ï¼ˆå¯é¸ï¼‰ï¼šæ¯ N ç§’å›å ±ï¼ˆwebhook ä¸å¡«å‰‡åªå¯«æ—¥èªŒï¼‰
  heartbeat:
    enabled: true
    interval_sec: 300
    webhook: ""      # ä¾‹å¦‚ "http://127.0.0.1:8787/heartbeat"
    note: "teams-bot-sender"

  # â‘¤ é€²éšï¼šDataFrameâ†’PNG èˆ‡ #help/#stats
  enable_pandas_image: false

rules:
  # â‘¤ è¦å‰‡ä¾‹å­ï¼ˆå¯æ”¹æˆä½ çš„ï¼‰
  - name: ping
    when: { contains: "#ping" }
    reply: { text: "pong" }
    cooldown_sec: 3

  - name: report_date
    when: { regex: "^å ±è¡¨(\\d{4}-\\d{2}-\\d{2})$" }
    reply: { text: "å·²æ”¶åˆ°å ±è¡¨æ—¥æœŸ {g1}ï¼Œé–‹å§‹è™•ç† âœ…" }
    cooldown_sec: 5

  - name: help_menu
    when: { equals: "#help" }
    reply: { builtin: "help" }   # â‘¤ å…§å»ºèªªæ˜ï¼šåˆ—å‡ºæ‰€æœ‰è¦å‰‡

  - name: stats1h
    when: { equals: "#stats" }
    reply: { builtin: "stats" }  # â‘¤ å…§å»ºçµ±è¨ˆï¼šè¿‘ä¸€å°æ™‚è§¸ç™¼æ•¸

  # - name: upload_table
  #   when: { contains: "ä¸Šå‚³è¡¨æ ¼" }
  #   reply:
  #     df_image: { title: "æœ€æ–°è¡¨æ ¼", outfile: "out/table.png" }  # å•Ÿç”¨æ™‚ sender.enable_pandas_image: true
  #   cooldown_sec: 10


---------------------------------------------------------------------------------

â‘¡ å•Ÿå‹•è…³æœ¬ï¼ˆWindowsï¼‰

start_sender.bat

@echo off
cd /d %~dp0
echo Starting sender_server.py ...
python sender_server.py
pause


start_watcher.bat

@echo off
cd /d %~dp0
echo Starting watcher.py ...
python watcher.py
pause


â‘¡ æ’ç¨‹å™¨ XMLï¼ˆé–‹æ©Ÿè‡ªå‹•åŸ·è¡Œï¼‰

è«‹æŠŠ <Arguments> è£¡ python å’Œè·¯å¾‘èª¿æˆä½ çš„å¯¦éš›ä½ç½®ã€‚åŒ¯å…¥åˆ°ã€Œå·¥ä½œæ’ç¨‹å™¨ã€â†’ å‹•ä½œï¼šå»ºç«‹åŸºæœ¬å·¥ä½œâ†’ åŒ¯å…¥é€™å€‹ XMLã€‚

task_sender.xml

<Task version="1.4" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <Description>Teams Sender Server (auto reply) on startup</Description>
  </RegistrationInfo>
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
      <Delay>PT10S</Delay>
    </LogonTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <RunLevel>LeastPrivilege</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <RestartOnFailure>
      <Interval>PT1M</Interval>
      <Count>3</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>python</Command>
      <Arguments>"C:\path\to\teams-bot\sender_server.py"</Arguments>
      <WorkingDirectory>C:\path\to\teams-bot</WorkingDirectory>
    </Exec>
  </Actions>
</Task>

task_watcher.xml
<Task version="1.4" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <Description>Teams Watcher (listen new messages) on startup</Description>
  </RegistrationInfo>
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
      <Delay>PT15S</Delay>
    </LogonTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <RunLevel>LeastPrivilege</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>true</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <RestartOnFailure>
      <Interval>PT1M</Interval>
      <Count>3</Count>
    </RestartOnFailure>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>python</Command>
      <Arguments>"C:\path\to\teams-bot\watcher.py"</Arguments>
      <WorkingDirectory>C:\path\to\teams-bot</WorkingDirectory>
    </Exec>
  </Actions>
</Task>


â‘¡ watcher.pyï¼ˆå¤šç›®æ¨™ç›£è½ + MutationObserver + é€äº‹ä»¶ + æ—¥èªŒï¼‰

å·²å…§åµŒ Shadow DOM / iframe æ·±åº¦ç›£è½ï¼ŒæœƒæŠŠæ¯å‰‡æ–°è¨Šæ¯é™„ä¸Š contextï¼ˆchatId æˆ– channelIdï¼‰é€åˆ° senderã€‚

# watcher.py
import os, time, json, urllib.request
from urllib.parse import quote
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# ---------- Config Loader (YAML/JSON) ----------
def load_config():
    for name in ("config.yaml","config.yml","config.json"):
        if os.path.exists(name):
            if name.endswith((".yaml",".yml")):
                try:
                    import yaml
                    with open(name,"r",encoding="utf-8") as f:
                        return yaml.safe_load(f)
                except Exception as e:
                    print(f"[watcher] YAML è§£æå¤±æ•—ï¼š{e}ï¼Œæ”¹è®€ JSON")
            else:
                with open(name,"r",encoding="utf-8") as f:
                    return json.load(f)
    raise SystemExit("æ‰¾ä¸åˆ° config.yaml/.yml/.json")

CFG = load_config()
SELF_NAME = (CFG.get("self_name") or "").strip()
WCFG = CFG["watcher"]
L = CFG.get("logging", {})
LOG_DIR = L.get("dir","logs")
LOG_FILE = os.path.join(LOG_DIR, L.get("watcher_event_file","watcher_events.ndjson"))
ROTATE_MB = int(L.get("rotate_mb", 10))

def ensure_dir(p):
    d = os.path.dirname(p)
    if d and not os.path.exists(d): os.makedirs(d, exist_ok=True)

def append_ndjson(path, obj):
    ensure_dir(path)
    # rotate
    if os.path.exists(path) and (os.path.getsize(path) > ROTATE_MB*1024*1024):
        base, ext = os.path.splitext(path)
        ts = time.strftime("%Y%m%d-%H%M%S")
        os.rename(path, f"{base}-{ts}{ext}")
    with open(path,"a",encoding="utf-8") as fp:
        fp.write(json.dumps(obj, ensure_ascii=False) + "\n")

# ---------- Selenium ----------
def new_driver():
    opt = webdriver.ChromeOptions()
    opt.add_experimental_option("debuggerAddress", WCFG["debugger_address"])
    srv = Service(WCFG["chromedriver_path"])
    d = webdriver.Chrome(service=srv, options=opt); d.implicitly_wait(0)
    return d

def open_target(drv, t):
    if t["type"] == "chat":
        url = f"https://teams.microsoft.com/_#/conversations/{t['chat_id']}?ctx=chat&web=1"
    else:
        url = ("https://teams.microsoft.com/l/channel/"
               f"{t['channel_id']}/{quote(t['channel_name'])}"
               f"?groupId={t['group_id']}&tenantId={t['tenant_id']}&web=1")
    drv.get(url)
    WebDriverWait(drv, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR,"body")))

MUTATION_JS = r"""
// Minimal TeamsWatch (deep + keepalive)
if (!window.__teamsObserverInstalled){
  window.__teamsObserverInstalled=true; window.__teamsEvents=[]; window.__teamsSeen=new Set(); window.__teamsObserver=null; window.__teamsTarget=null;
}
function qAllDeep(root,sel){ const out=[...root.querySelectorAll(sel)]; const it=root.querySelectorAll('*');
  for(const el of it) if(el.shadowRoot) out.push(...el.shadowRoot.querySelectorAll(sel));
  if(root.shadowRoot) out.push(...root.shadowRoot.querySelectorAll(sel)); return out; }
function qAllDocs(sel){
  let arr=qAllDeep(document,sel); if(arr.length) return arr;
  for(const f of document.querySelectorAll('iframe')){ try{ const d=f.contentDocument||f.contentWindow?.document; if(!d) continue; arr=qAllDeep(d,sel); if(arr.length) return arr; }catch(e){} }
  return [];
}
function findList(){ const c=["[data-tid*='messageList']","[data-tid*='chat-message-list']","[aria-label*='messages list']","[aria-label*='è¨Šæ¯æ¸…å–®']","[role='list']"];
  for(const s of c){ const arr=qAllDocs(s); if(arr.length){ arr.sort((a,b)=>(b.scrollHeight*b.scrollWidth)-(a.scrollHeight*a.scrollWidth)); return arr[0]; } } return null; }
function getText(el){ const c=["[data-tid*='messageContent']","[data-tid*='message-body']","[data-tid*='messageBody']","[data-tid*='text-content']","[role='document']",".chat-message-container"];
  for(const s of c){ const t=el.querySelector(s)||(el.shadowRoot&&el.shadowRoot.querySelector(s)); if(t&&t.innerText) return t.innerText.trim(); } return (el.innerText||"").trim(); }
function getSender(el){ const c=["[data-tid*='messageAuthor']","[data-tid*='author-name']","[data-tid*='sender']","[aria-label*='said']","[aria-label*='èªª']"];
  for(const s of c){ const t=el.querySelector(s)||(el.shadowRoot&&el.shadowRoot.querySelector(s));
    if(!t) continue; if(t.innerText) return t.innerText.trim(); if(t.getAttribute){ const al=t.getAttribute('aria-label'); if(al) return al; } } return null; }
function getTime(el){ const c=["time[datetime]","[data-tid*='timestamp']","[data-tid*='messageTime']"];
  for(const s of c){ const t=el.querySelector(s)||(el.shadowRoot&&el.shadowRoot.querySelector(s)); if(!t) continue;
    const dt=t.getAttribute&&t.getAttribute('datetime'); if(dt) return dt; if(t.innerText) return t.innerText.trim(); } return new Date().toISOString(); }
function mkHash(a,b,c){ const s=JSON.stringify({a,b,c}); let h=0; for(let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return "m_"+(h>>>0).toString(16); }
function harvest(el){ const isMsg=el.matches?.("[role='listitem'], [data-tid*='message']"); const hasChild=el.querySelector?.("[role='listitem'], [data-tid*='message']");
  if(!isMsg && !hasChild) return; const items=isMsg?[el]:[...el.querySelectorAll("[role='listitem'], [data-tid*='message']")];
  for(const it of items){ const text=getText(it); if(!text) continue; const sender=getSender(it); const time=getTime(it);
    const id=(it.id && it.id.length? it.id : mkHash(sender,text,time)); if(window.__teamsSeen.has(id)) continue; window.__teamsSeen.add(id);
    window.__teamsEvents.push({id, sender, text, time, ts: Date.now()}); } }
function install(){ if(window.__teamsObserver&&window.__teamsTarget){ try{window.__teamsObserver.disconnect();}catch{} }
  const list=findList(); if(!list) return 'not_found'; qAllDeep(list,"[role='listitem'], [data-tid*='message']").forEach(harvest);
  const mo=new MutationObserver(muts=>{ for(const m of muts){ if(m.type==='childList'&&m.addedNodes?.length){ m.addedNodes.forEach(n=>{ if(n.nodeType===1) harvest(n); }); } } });
  mo.observe(list,{childList:true,subtree:true}); window.__teamsObserver=mo; window.__teamsTarget=list; return 'wired'; }
if(!window.__teamsKeepAlive){ window.__teamsKeepAlive=setInterval(()=>{ try{ if(!window.__teamsTarget || !document.contains(window.__teamsTarget)) install(); }catch(e){} },1500); }
window.TeamsWatch={install, fetch:()=>{ const out=window.__teamsEvents.slice(); window.__teamsEvents.length=0; return out; }, alive:()=>!!(window.__teamsObserver&&window.__teamsTarget&&document.contains(window.__teamsTarget))};
TeamsWatch.install();
"""

def route_info(drv):
    href = drv.execute_script("return location.href")
    info = {"url": href, "kind":"unknown"}
    if "/conversations/" in href:
        import re
        m = re.search(r"/conversations/(19:[^/?#]+@thread\.tacv2)", href)
        if m: info.update({"kind":"chat","chatId":m.group(1)})
    elif "/l/channel/" in href:
        from urllib.parse import urlparse, parse_qs, unquote
        p = urlparse(href); q = parse_qs(p.query)
        parts = p.path.split("/l/channel/",1)[1].split("/",1)
        info.update({"kind":"channel","channelId":parts[0],
                     "groupId":q.get("groupId",[None])[0],
                     "tenantId":q.get("tenantId",[None])[0],
                     "channelName": unquote(parts[1].split("?")[0]) if len(parts)>1 else None})
    return info

def post_events(batch):
    data = json.dumps(batch, ensure_ascii=False).encode("utf-8")
    req = urllib.request.Request(WCFG["sender_endpoint"], data=data,
                                 headers={"Content-Type":"application/json; charset=utf-8"},
                                 method="POST")
    with urllib.request.urlopen(req, timeout=5) as resp:
        resp.read()

def main():
    d = new_driver()
    handles, metas = [], []
    for t in WCFG["targets"]:
        d.switch_to.new_window('tab')
        handles.append(d.current_window_handle)
        metas.append(t)
        open_target(d, t)
        d.execute_script(MUTATION_JS)

    try:
        while True:
            for h, meta in zip(handles, metas):
                d.switch_to.window(h)
                # ç¢ºèªå­˜æ´»ï¼›ä¸åœ¨å°±é‡è£
                try:
                    alive = d.execute_script("return window.TeamsWatch && TeamsWatch.alive()")
                except Exception: alive = False
                if not alive:
                    try: d.execute_script(MUTATION_JS)
                    except Exception: pass

                # å–äº‹ä»¶
                try:
                    evs = d.execute_script("return window.TeamsWatch ? TeamsWatch.fetch() : []") or []
                except Exception:
                    evs = []

                if not evs:
                    continue

                ctx = route_info(d)
                batch = []
                for ev in evs:
                    if SELF_NAME and (ev.get("sender") or "").strip() == SELF_NAME:
                        continue
                    ev["context"] = ctx
                    ev["note"] = meta.get("note")
                    append_ndjson(LOG_FILE, {"type":"event","ev":ev})
                    batch.append(ev)

                if batch:
                    try: post_events(batch)
                    except Exception as e:
                        append_ndjson(LOG_FILE, {"type":"post_error","error":str(e)})
            time.sleep(float(WCFG.get("poll_interval_sec", 2.0)))
    except KeyboardInterrupt:
        pass

if __name__ == "__main__":
    main()

------------------------------------------------------------------------

â‘¡ï¼‹â‘£ï¼‹â‘¤ sender_server.pyï¼ˆè¦å‰‡å¼•æ“ / å¤šç¾¤è·¯ç”± / ç™½åå–® / å¿ƒè·³ / #help / #stats / ç”¢åœ–ï¼‰

# sender_server.py
import os, json, re, time, threading, urllib.request
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from urllib.parse import urlparse
from collections import defaultdict, deque

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# ---------- Config Loader ----------
def load_config():
    for name in ("config.yaml","config.yml","config.json"):
        if os.path.exists(name):
            if name.endswith((".yaml",".yml")):
                try:
                    import yaml
                    with open(name,"r",encoding="utf-8") as f:
                        return yaml.safe_load(f)
                except Exception as e:
                    print(f"[sender] YAML è§£æå¤±æ•—ï¼š{e}ï¼Œæ”¹è®€ JSON")
            else:
                with open(name,"r",encoding="utf-8") as f:
                    return json.load(f)
    raise SystemExit("æ‰¾ä¸åˆ° config.yaml/.yml/.json")

CFG = load_config()
SELF_NAME = (CFG.get("self_name") or "").strip()
SCFG = CFG["sender"]
L = CFG.get("logging", {})
LOG_DIR = L.get("dir","logs")
LOG_FILE = os.path.join(LOG_DIR, L.get("sender_action_file","sender_actions.ndjson"))
ROTATE_MB = int(L.get("rotate_mb", 10))

def ensure_dir(p):
    d = os.path.dirname(p)
    if d and not os.path.exists(d): os.makedirs(d, exist_ok=True)

def append_ndjson(path, obj):
    ensure_dir(path)
    if os.path.exists(path) and (os.path.getsize(path) > ROTATE_MB*1024*1024):
        base, ext = os.path.splitext(path); ts = time.strftime("%Y%m%d-%H%M%S")
        os.rename(path, f"{base}-{ts}{ext}")
    with open(path,"a",encoding="utf-8") as fp:
        fp.write(json.dumps(obj, ensure_ascii=False) + "\n")

# ---------- Selenium ----------
_driver = None
_send_lock = threading.Lock()

def ensure_driver():
    global _driver
    try:
        if _driver is None:
            opts = webdriver.ChromeOptions()
            opts.add_experimental_option("debuggerAddress", SCFG["debugger_address"])
            srv = Service(SCFG["chromedriver_path"])
            _driver = webdriver.Chrome(service=srv, options=opts); _driver.implicitly_wait(0)
        else:
            _driver.execute_script("return 1")
    except Exception:
        opts = webdriver.ChromeOptions()
        opts.add_experimental_option("debuggerAddress", SCFG["debugger_address"])
        srv = Service(SCFG["chromedriver_path"])
        _driver = webdriver.Chrome(service=srv, options=opts); _driver.implicitly_wait(0)

def open_chat(chat_id):
    _driver.get(f"https://teams.microsoft.com/_#/conversations/{chat_id}?ctx=chat&web=1")
    WebDriverWait(_driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR,"body")))

def open_channel(channel_id, group_id, tenant_id, channel_name):
    from urllib.parse import quote
    url = ("https://teams.microsoft.com/l/channel/"
           f"{channel_id}/{quote(channel_name or 'ä¸€èˆ¬')}"
           f"?groupId={group_id}&tenantId={tenant_id}&web=1")
    _driver.get(url)
    WebDriverWait(_driver, 60).until(EC.presence_of_element_located((By.CSS_SELECTOR,"body")))

def find_compose(timeout=40):
    end = time.time() + timeout
    while time.time() < end:
        els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
        if els: return els[0]
        iframes = _driver.find_elements(By.CSS_SELECTOR, "iframe")
        for f in iframes:
            try:
                _driver.switch_to.default_content(); _driver.switch_to.frame(f)
                els = _driver.find_elements(By.CSS_SELECTOR, "[contenteditable='true'][role='textbox']")
                if els: return els[0]
            except Exception: pass
        _driver.switch_to.default_content(); time.sleep(0.2)
    raise RuntimeError("æ‰¾ä¸åˆ°è¼¸å…¥æ¡†")

def send_text(text):
    box = find_compose(40); box.click()
    for line in text.split("\n"): box.send_keys(line); box.send_keys(Keys.SHIFT, Keys.ENTER)
    box.send_keys(Keys.BACK_SPACE)
    try: box.send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(_driver, 10).until(EC.element_to_be_clickable((
            By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"
        ))); btn.click()
    WebDriverWait(_driver, 20).until(EC.presence_of_element_located((
        By.CSS_SELECTOR, "[data-tid*='messageContent'], .chat-message-container"
    )))

# --- æ·±åº¦æ‰¾ file input ä¸¦ä¸Šå‚³åœ–ç‰‡ ---
def q_all_deep(selector):
    js = r"""
const sel = arguments[0];
function qAllDeep(root,s){ const out=[...root.querySelectorAll(s)]; const it=root.querySelectorAll('*');
  for(const el of it) if(el.shadowRoot) out.push(...el.shadowRoot.querySelectorAll(s));
  if(root.shadowRoot) out.push(...root.shadowRoot.querySelectorAll(s)); return out; }
function allDocs(s){ let arr=qAllDeep(document,s); if(arr.length) return arr;
  for(const f of document.querySelectorAll('iframe')){ try{ const d=f.contentDocument||f.contentWindow?.document; if(!d) continue; arr=qAllDeep(d,s); if(arr.length) return arr; }catch(e){} }
  return []; }
return allDocs(sel);
"""
    return _driver.execute_script(js, selector)

def click_attach_if_needed():
    try:
        btn = WebDriverWait(_driver, 3).until(EC.element_to_be_clickable((
          By.CSS_SELECTOR, "button[aria-label*='é™„åŠ '], button[aria-label*='æª”æ¡ˆ'], button[aria-label='Attach'], [data-tid*='attach']"
        ))); btn.click(); time.sleep(0.4)
    except Exception: pass

def upload_image(path):
    click_attach_if_needed()
    inputs = q_all_deep("input[type='file']")
    if not inputs: raise RuntimeError("æ‰¾ä¸åˆ° input[type=file]")
    abs_path = os.path.abspath(path); last = None
    for inp in inputs:
        try: inp.send_keys(abs_path); break
        except Exception as e: last = e
    else:
        raise RuntimeError(f"file input send_keys å¤±æ•—: {last}")
    try:
        WebDriverWait(_driver, 12).until(EC.presence_of_element_located((
            By.CSS_SELECTOR, "[data-tid*='filePreview'], [data-tid*='attachment'], [data-tid*='imagePreview'], [role='listitem'] img"
        )))
    except Exception: pass

def send_image_with_caption(path, caption=None):
    upload_image(path)
    if caption:
        box = find_compose(20); box.click(); box.send_keys(caption)
    try: find_compose(5).send_keys(Keys.ENTER)
    except Exception:
        btn = WebDriverWait(_driver, 10).until(EC.element_to_be_clickable((
            By.CSS_SELECTOR, "button[aria-label='Send'], button[aria-label*='å‚³é€'], button[aria-label*='ç™¼é€']"
        ))); btn.click()

# --- å¯é¸ï¼šDataFrameâ†’PNG ---
def df_to_png(df, out_png, title=None, dpi=200):
    import matplotlib.pyplot as plt
    n_rows, n_cols = df.shape; cell_h, cell_w = 0.6, 2.2
    title_h = 0.6 if title else 0.2
    fig_w = max(6, n_cols*cell_w); fig_h = max(2.5, n_rows*cell_h + title_h)
    fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi); ax.axis("off")
    tbl = ax.table(cellText=df.values, colLabels=df.columns, loc='center', cellLoc='center', colLoc='center')
    tbl.auto_set_font_size(False); tbl.set_fontsize(10); tbl.scale(1, 1.25)
    for (r,c), cell in tbl.get_celld().items():
        if r==0: cell.set_text_props(weight='bold'); cell.set_facecolor("#f0f0f0")
        cell.set_edgecolor("#ccc")
    if title: ax.set_title(title, pad=10, fontsize=14, fontweight='bold')
    os.makedirs(os.path.dirname(out_png), exist_ok=True) if os.path.dirname(out_png) else None
    plt.tight_layout(); plt.savefig(out_png, bbox_inches='tight', dpi=dpi); plt.close(fig)
    return out_png

# ---------- ç™½åå–®æª¢æŸ¥ ----------
def in_whitelist(ctx):
    wl = (SCFG.get("whitelist") or {})
    if ctx.get("kind")=="chat":
        return ctx.get("chatId") in (wl.get("chats") or [])
    if ctx.get("kind")=="channel":
        for c in (wl.get("channels") or []):
            if (ctx.get("channelId")==c.get("channel_id")
                and ctx.get("groupId")==c.get("group_id")
                and ctx.get("tenantId")==c.get("tenant_id")):
                return True
        return False
    return False

# ---------- è¦å‰‡å¼•æ“ & å…§å»ºå›è¦† (#help/#stats) ----------
RULES = CFG.get("rules", [])

def rule_list_text():
    lines = ["å¯ç”¨æŒ‡ä»¤ / è¦å‰‡ï¼š"]
    for r in RULES:
        cond = r.get("when", {})
        desc = next((f"{k}={v}" for k,v in cond.items()), "ï¼ˆæœªå®šç¾©ï¼‰")
        lines.append(f"- {r.get('name')}ï¼š{desc}")
    return "\n".join(lines)

# ç°¡æ˜“çµ±è¨ˆï¼šè¿‘ 1 å°æ™‚è§¸ç™¼æ•¸
_stats = deque(maxlen=5000)  # (ts, rule_name, scope_key)
def push_stat(rule_name, ctx):
    scope = ("chat", ctx.get("chatId")) if ctx.get("kind")=="chat" else ("channel", ctx.get("channelId"))
    _stats.append((time.time(), rule_name, scope))

def stats_1h_text():
    now = time.time()
    counts = defaultdict(int)
    for ts, rname, scope in list(_stats):
        if now - ts <= 3600:
            counts[(rname, scope)] += 1
    if not counts: return "è¿‘ä¸€å°æ™‚æ²’æœ‰è§¸ç™¼ç´€éŒ„ã€‚"
    lines = ["è¿‘ä¸€å°æ™‚è§¸ç™¼çµ±è¨ˆï¼š"]
    for (rname, scope), n in counts.items():
        lines.append(f"- {rname} @ {scope}: {n}")
    return "\n".join(lines)

def apply_rule(ev):
    sender = (ev.get("sender") or "").strip()
    if SELF_NAME and sender == SELF_NAME:
        return None
    ctx = ev.get("context") or {}
    if not in_whitelist(ctx):
        append_ndjson(LOG_FILE, {"type":"deny_non_whitelist","ctx":ctx})
        return None

    text = (ev.get("text") or "")
    for r in RULES:
        cond = r.get("when", {})
        matched = False; groups=[]
        if "contains" in cond: matched = cond["contains"] in text
        elif "startswith" in cond: matched = text.startswith(cond["startswith"])
        elif "equals" in cond: matched = text == cond["equals"]
        elif "regex" in cond:
            m = re.search(cond["regex"], text); matched = m is not None
            if m and m.lastindex: groups = [m.group(i) for i in range(1, m.lastindex+1)]
        if not matched: continue

        # å†·å»ï¼ˆä»¥è¦å‰‡ + ä¾†æº scope ç‚ºå–®ä½ï¼‰
        scope = ("chat", ctx.get("chatId")) if ctx.get("kind")=="chat" else ("channel", ctx.get("channelId"), ctx.get("groupId"))
        key = (r.get("name"), scope)
        cooldown = int(r.get("cooldown_sec", 0))
        now = time.time()
        last = _cooldown.get(key, 0)
        if now - last < cooldown:
            return None
        _cooldown[key] = now

        # å…§å»ºå›è¦†
        rep = r.get("reply", {})
        if rep.get("builtin") == "help":
            return {"type":"text", "text": rule_list_text(), "rule": r.get("name")}
        if rep.get("builtin") == "stats":
            return {"type":"text", "text": stats_1h_text(), "rule": r.get("name")}

        # æ–‡å­—/åœ–ç‰‡/è¡¨æ ¼åœ–ç‰‡
        if "text" in rep:
            msg = rep["text"]
            for i, g in enumerate(groups, 1):
                msg = msg.replace(f"{{g{i}}}", g)
            return {"type":"text", "text": msg, "rule": r.get("name")}
        if "image" in rep:
            return {"type":"image", "path": rep["image"], "caption": rep.get("caption"), "rule": r.get("name")}
        if "df_image" in rep:
            return {"type":"df_image", "title": rep["df_image"].get("title","å ±è¡¨"),
                    "outfile": rep["df_image"].get("outfile","out/table.png"), "rule": r.get("name")}
    return None

_cooldown = {}  # (rule_name, scope) -> ts

def act_reply(ctx, action):
    # è·¯ç”±åˆ°ä¾†æº
    if ctx.get("kind")=="chat" and ctx.get("chatId"): open_chat(ctx["chatId"])
    elif ctx.get("kind")=="channel": open_channel(ctx["channelId"], ctx["groupId"], ctx["tenantId"], ctx.get("channelName"))
    else: raise RuntimeError("æœªçŸ¥ context")

    t = action["type"]
    if t=="text":
        send_text(action["text"])
    elif t=="image":
        send_image_with_caption(action["path"], action.get("caption"))
    elif t=="df_image":
        if not SCFG.get("enable_pandas_image", False):
            send_text("(æç¤º) å°šæœªå•Ÿç”¨ DataFrameâ†’PNGã€‚è«‹åœ¨ config.yaml æ‰“é–‹ sender.enable_pandas_imageã€‚")
        else:
            try:
                import pandas as pd
                df = pd.DataFrame({"ç”¢å“":["A","B","C"],"éŠ·é‡":[12,18,9],"é€€è²¨ç‡":[0.5,0.9,0.2]})
                png = df_to_png(df, action.get("outfile","out/table.png"), title=action.get("title"))
                send_image_with_caption(png, caption=action.get("title"))
            except Exception as e:
                send_text(f"(ç”¢åœ–å¤±æ•—) {e}")

# ---------- HTTP Server ----------
class Handler(BaseHTTPRequestHandler):
    def _json(self, code, obj):
        body = json.dumps(obj, ensure_ascii=False).encode("utf-8")
        self.send_response(code)
        self.send_header("Content-Type","application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body))); self.end_headers()
        self.wfile.write(body)

    def do_GET(self):
        if urlparse(self.path).path == "/health":
            return self._json(200, {"ok":True, "ts": time.time()})
        if urlparse(self.path).path == "/stats":
            return self._json(200, {"stats_text": stats_1h_text()})
        return self._json(404, {"error":"not found"})

    def do_POST(self):
        if urlparse(self.path).path != "/event":
            return self._json(404, {"error":"not found"})
        try:
            n = int(self.headers.get("Content-Length","0"))
            raw = self.rfile.read(n)
            payload = json.loads(raw.decode("utf-8"))
        except Exception as e:
            return self._json(400, {"error": f"bad json: {e}"})

        events = payload if isinstance(payload, list) else [payload]
        results = []
        for ev in events:
            try:
                action = apply_rule(ev)
                if action:
                    with _send_lock:
                        ensure_driver()
                        act_reply(ev.get("context") or {}, action)
                    push_stat(action.get("rule","?"), ev.get("context") or {})
                    results.append({"id": ev.get("id"), "replied": True})
                    append_ndjson(LOG_FILE, {"type":"reply","rule":action.get("rule"),"ev":ev})
                else:
                    results.append({"id": ev.get("id"), "replied": False})
                    append_ndjson(LOG_FILE, {"type":"skip","ev":ev})
            except Exception as e:
                results.append({"id": ev.get("id"), "error": str(e)})
                append_ndjson(LOG_FILE, {"type":"error","error":str(e),"ev":ev})
        return self._json(200, {"ok": True, "results": results})

    def log_message(self, *args, **kwargs):
        pass

# ---------- å¿ƒè·³ï¼ˆâ‘¢ï¼‰ ----------
def heartbeat_loop():
    cfg = SCFG.get("heartbeat") or {}
    if not cfg.get("enabled"): return
    interval = int(cfg.get("interval_sec", 300))
    target = cfg.get("webhook","").strip()
    note = cfg.get("note","teams-bot-sender")
    while True:
        payload = {"ok":True, "ts": time.time(), "note": note}
        append_ndjson(LOG_FILE, {"type":"heartbeat","payload":payload})
        if target:
            try:
                data = json.dumps(payload).encode("utf-8")
                req = urllib.request.Request(target, data=data,
                    headers={"Content-Type":"application/json"}, method="POST")
                urllib.request.urlopen(req, timeout=5).read()
            except Exception as e:
                append_ndjson(LOG_FILE, {"type":"heartbeat_post_error","error":str(e)})
        time.sleep(interval)

if __name__ == "__main__":
    t = threading.Thread(target=heartbeat_loop, daemon=True); t.start()
    srv = ThreadingHTTPServer((SCFG["bind_host"], int(SCFG["bind_port"])), Handler)
    print(f"sender_server listening on http://{SCFG['bind_host']}:{SCFG['bind_port']}/event")
    try:
        srv.serve_forever()
    except KeyboardInterrupt:
        print("sender_server stopped.")

------------------------------------------------------------------------------------

â‘¢ æ—¥èªŒèˆ‡å¯è§€æ¸¬æ€§

å…©é‚Šéƒ½å¯« NDJSON åˆ° logs/ï¼Œæ¯è¡Œä¸€å€‹ JSONï¼ˆå®¹æ˜“ tailã€grepã€ç”¨ pandas è®€ï¼‰ã€‚

è¶…é rotate_mb è‡ªå‹•åˆ‡æª”ï¼ˆåŠ ä¸Šæ™‚é–“æˆ³ï¼‰ã€‚

sender å¦å¤–æä¾› GET /health èˆ‡ GET /statsï¼ˆå¿«é€Ÿæª¢æŸ¥æœå‹™/çµ±è¨ˆï¼‰ã€‚

----------------------------------------------------------------------------------

â‘£ å®‰å…¨èˆ‡é˜²å‘†ï¼ˆç™½åå–®ï¼‹é›™é‡é˜²å›è²ï¼‰

config.yaml > sender.whitelist æŒ‡å®šå…è¨±å›è¦†çš„ chat/channelï¼ˆå…¶é¤˜å…¨éƒ¨æ‹’çµ•ï¼‰ã€‚


â‘¤ é€²éšåŠŸèƒ½

#helpï¼šå›è¦†ç›®å‰æ‰€æœ‰è¦å‰‡ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰ã€‚

#statsï¼šå›è¦†è¿‘ä¸€å°æ™‚æ¯å€‹è¦å‰‡çš„è§¸ç™¼æ•¸ï¼ˆä¾ä¾†æºåˆ† scopeï¼‰ã€‚

DataFrameâ†’PNGï¼šæŠŠ sender.enable_pandas_image: trueï¼Œå®‰è£ pandasã€matplotlib å¾Œ
ï¼Œå•Ÿç”¨ df_image é¡å‹çš„å›è¦†å³å¯ï¼ˆç¯„ä¾‹å·²åœ¨ config.yamlï¼‰ã€‚

watcher & sender éƒ½æœƒç”¨ self_name éæ¿¾è‡ªå·±ç™¼çš„è¨Šæ¯ï¼Œé˜²æ­¢å›è²ã€‚


-----------------------------------------------------------------------
å¿«é€Ÿä¸Šç·šæ­¥é©Ÿ

å…ˆæŠŠ config.yaml è£¡çš„ chat_id / channel_id / group_id / tenant_idã€debugger_addressã€chromedriver_path æ”¹æˆä½ çš„å€¼ã€‚

é–‹å•Ÿ sender_server.pyï¼špython sender_server.py

é–‹å•Ÿ watcher.pyï¼špython watcher.py

åœ¨è¢«ç›£è½çš„ç¾¤çµ„è¼¸å…¥ #pingã€#helpã€#stats æ¸¬è©¦ã€‚

------------------------------------------------------------------------

è¦æˆ‘å¹«ä½ æŠŠæ•´å¥—ã€Œå¯ç›´æ¥è·‘ã€çš„ config.yaml å¡«å¥½ä¹Ÿè¡Œâ€”çµ¦æˆ‘é€™ä¸‰æ¨£å°±èƒ½ç”Ÿæˆï¼š

ä½ çš„ Teams é¡¯ç¤ºåç¨±ï¼ˆself_nameï¼Œç”¨ä¾†é˜²å›è²ï¼‰

ç›£è½ç›®æ¨™ï¼š

èŠå¤©ï¼šchatIdï¼ˆåƒ 19:...@thread.tacv2ï¼‰

æˆ–é »é“é€£çµï¼ˆå« channelId / groupId / tenantId / channelNameï¼‰

æƒ³è¦çš„ é—œéµå­—ï¼æ­£å‰‡ â†’ å›è¦† æ¸…å–®ï¼ˆè¦ä¸è¦é™å®šåœ¨ç‰¹å®šç¾¤çµ„ä¹Ÿä¸€èµ·èªªï¼‰

åŒæ™‚é™„ä¸Šè¶…çŸ­ã€Œèµ·è·‘æ¸…å–®ã€å†ç¢ºèªä¸€ä¸‹å³å¯ï¼š

å·²ç”¨ --remote-debugging-port=9992 å•Ÿå‹•/é™„è‘— Chromeï¼Œä¸”å·²ç™»å…¥ teams.microsoft.com

config.yamlï¼šå¡«å¥½ watcher.targetsã€sender.whitelistã€rules

å…ˆè·‘ sender_server.pyï¼Œå†è·‘ watcher.py

åœ¨ç¾¤çµ„æ¸¬ #pingã€#helpã€#stats çœ‹å›è¦†æ˜¯å¦æ­£ç¢º










































































